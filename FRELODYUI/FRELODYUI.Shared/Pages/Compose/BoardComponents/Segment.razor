@using FRELODYUI.Shared.Pages.Compose.ChordComponents
@using FRELODYSHRD.ModelTypes
@inject ILogger<Segment> _logger

<div class="@($"h-100 w-100 d-flex align-items-between rounded cursor-pointer {(FocusedLine ? "bg-dark" : "bg-secondary")}")">
    @if (Editing)
    {
        <AddSegment @ref="addSegmentRef"
                    @bind-SelectedChord="selectedChord"
                    @bind-FormOpen="Editing"
                    IsMidSegments="true"
                    SegmentText="@Content.Lyric"
                    OnCancel= "HandleCancel"
                    TextBoxSize="TextBoxSize"
                    OnSegmentAdded="HandleSegmentEdited"/>
    }
    else
    {
        <div class="d-flex flex-column justify-content-between py-2 m-2" style="@TextBoxSize">
            <div class="d-flex align-items-center position-relative @GetChordAlignmentClass()">
                @if (!string.IsNullOrEmpty(ChordName))
                {
                    @if (ShowAlign)
                    {
                        @* Left unindent icon - show when center or right aligned *@
                        @if (Content.ChordAlignment == Alignment.Center || Content.ChordAlignment == Alignment.Right)
                        {
                            <i class="bi bi-unindent text-primary cursor-pointer me-1"
                               @onclick="HandleUnindentClick"
                               title="Move chord left"></i>
                        }
                    }
                   
                    
                    @* Chord name with dynamic alignment *@
                    <h6 class="fw-bolder text-white align-self-center m-0" 
                       @onclick="()=> ShowAlign = !ShowAlign"
                       style="cursor: pointer;">@ChordName</h6>

                    @if (ShowAlign)
                    {
                        @* Right indent icon - show when left or center aligned *@
                        @if (Content.ChordAlignment == Alignment.Left || Content.ChordAlignment == Alignment.Center)
                        {
                            <i class="bi bi-indent text-primary cursor-pointer ms-1"
                               @onclick="HandleIndentClick"
                               title="Move chord right"></i>
                        }
                    }
                }
            </div>
            <div>
                <h6 class="fw-normal text-white m-0">@Content.Lyric</h6>
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public SegmentCreateDto Content { get; set; } = default!;
    [Parameter] public bool Editing { get; set; }
    [Parameter] public bool FocusedLine { get; set; }
    [Parameter] public string TextBoxSize { get; set; } = "width:8rem;"; 
    [Parameter] public EventCallback<SegmentCreateDto> OnSave { get; set; }
    [Parameter] public EventCallback OnCancel { get; set; }
    [Parameter] public EventCallback<SegmentCreateDto> OnDragStart { get; set; }
    [Parameter] public EventCallback<SegmentCreateDto> SegmentRemoved { get; set; }

    private ChordDto selectedChord = new();
    private string ChordName = string.Empty;
    private bool isInitialized = false;
    private AddSegment addSegmentRef = default!;
    private bool ShowAlign = false;

    protected async override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            if (!isInitialized)
            {
                if (!string.IsNullOrEmpty(Content.Id))
                {
                    ChordName = Content.ChordName ?? string.Empty;
                    if (string.IsNullOrEmpty(ChordName) && !string.IsNullOrEmpty(Content.ChordId))
                    {
                        selectedChord = await GetChord(Content.ChordId);
                    }
                }
                isInitialized = true;
                StateHasChanged();
            }
        }
    }

    private string GetChordAlignmentClass()
    {
        return Content.ChordAlignment switch
        {
            Alignment.Left => "justify-content-start",
            Alignment.Center => "justify-content-center",
            Alignment.Right => "justify-content-end",
            Alignment.Justify => "justify-content-between",
            _ => "justify-content-start"
        };
    }

    private async Task HandleIndentClick()
    {
        // Move chord alignment to the right
        Content.ChordAlignment = Content.ChordAlignment switch
        {
            Alignment.Left => Alignment.Center,
            Alignment.Center => Alignment.Right,
            _ => Content.ChordAlignment
        };

        await OnSave.InvokeAsync(Content);
        StateHasChanged();
    }

    private async Task HandleUnindentClick()
    {
        // Move chord alignment to the left
        Content.ChordAlignment = Content.ChordAlignment switch
        {
            Alignment.Right => Alignment.Center,
            Alignment.Center => Alignment.Left,
            _ => Content.ChordAlignment
        };

        await OnSave.InvokeAsync(Content);
        StateHasChanged();
    }

    private async Task HandleDragStart()
    {
        await OnDragStart.InvokeAsync(Content);
    }

    private void HandleCancel()
    {
        Editing = false; 
        if (string.IsNullOrEmpty(Content.ChordName) && string.IsNullOrEmpty(Content.Lyric))
        {
            if (SegmentRemoved.HasDelegate)
                SegmentRemoved.InvokeAsync(Content);
        }
        else
        {
            if(OnCancel.HasDelegate)
                OnCancel.InvokeAsync();
        }
    }

    private void HandleSegmentEdited(SegmentCreateDto editedSegment)
    {
        if (editedSegment != null)
        {
            Content.Lyric = editedSegment.Lyric;
            Content.ChordId = editedSegment.ChordId;
            Content.ChordName = editedSegment.ChordName;
            Content.AddNextSegment = editedSegment.AddNextSegment;
            Content.ChordAlignment = editedSegment.ChordAlignment;
            ChordName = editedSegment.ChordName ?? string.Empty;
        }
        else
        {
            Content.Lyric = string.Empty;
            Content.ChordId = string.Empty;
            Content.ChordName = string.Empty;
            Content.AddNextSegment = false;
            Content.ChordAlignment = Alignment.Left;
            ChordName = string.Empty;
        }
        OnSave.InvokeAsync(Content);
    }

    public void SetSelectedChord(ChordDto chord)
    {
        selectedChord = chord;
        Content.ChordId = chord.Id;
        Content.ChordName = chord.ChordName;
        ChordName = chord.ChordName ?? string.Empty;
        StateHasChanged();
    }

    public async Task<ChordDto> GetChord(string chordId)
    {
        try
        {            
            var response = await _chordsApi.GetChordById(chordId);
            if (response.IsSuccessStatusCode)
            {
                return response.Content!;
            }
            else
            {
                var errorMessage = _apiResponseHandler.GetApiErrorMessage(response);
                _logger.LogError("Error getting chord: {Error}", errorMessage);
                return new ChordDto();
            }
        }
        catch (Exception ex)
        {
            _logger.LogError("Error getting chord: {Error}", ex);
            return new ChordDto();
        }
    }

    public async Task HandleEditedAndExitAsync()
    {
        if (addSegmentRef != null && addSegmentRef.FormOpen)
        {
            await addSegmentRef.SubmitAndExitAsync();
        }
    }

    public void HandleEditedAndExit()
    {
        _ = HandleEditedAndExitAsync();
    }
}