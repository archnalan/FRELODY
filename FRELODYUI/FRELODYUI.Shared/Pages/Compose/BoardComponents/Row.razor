@using FRELODYSHRD.Dtos.EditDtos
@inject ILogger<Row> _logger

<div tabindex="0" 
     class="@($"w-100 position-relative d-flex flex-wrap gap-3 bg-white" + 
            $" {(Focused ? "border border-primary" : "border border-secondary")}")"
     style="@(Focused ? "padding:2.5rem" : "padding:1.75rem");border-radius:1rem; border-bottom-right-radius:0.5rem">
    <div class="@($"position-absolute top-0 start-0 badge {(Focused ? "bg-primary mt-2 ms-2" : "mt-1 ms-3")}")">
        Lyric Line @Line.ToString("00")
        @if (Focused)
        {
            <i class="bi bi-chevron-down ms-2" @onclick="() => ToggleDropdown(!showDropdown)"></i>
            @if (showDropdown)
            {
                <RowActions Visible="@showDropdown"
                            CurrentLine="Line" 
                            AllLines="lineNumbers"
                            VisibleChanged="HandleVisbileChanged"
                            OnActionConfirmed="HandleActionConfirmed"/>
            }
        }
    </div>

    <SortableList Id="@($"sortable-segments-{Line}")"
                  Items="filteredSegments"
                  OnUpdate="@SortSegments"
                  Context="segment"
                  Class="d-flex flex-wrap w-100 gap-1"
                  Style="@textBoxSize">
        <SortableItemTemplate>
            <div data-id="@segment.Id" @ondblclick="() => HandleDoubleClick(segment)">
                <Segment @ref="segmentRefs[segment.Id]"
                         Content="segment"
                         Editing="@(EditingSegment?.Id == segment.Id)"
                         FocusedLine="Focused"
                         TextBoxSize="@textBoxSize"
                         OnSave="HandleSave"
                         OnCancel="HandleCancel"
                         OnDragStart="HandleDragStart" 
                         SegmentRemoved="HandleSegmentRemoved" />
            </div>
        </SortableItemTemplate>
        <ActionItemTemplate>
            <AddSegment @ref="addSegmentRef"
                        @bind-FormOpen="addFormOpen"
                        OnSegmentAdded="HandleSegmentAdded"
                        TextBoxSize="@textBoxSize"
                        FocusedLine="Focused"
                        OnCancel="HandleCancel"
                        ClosePrevForm="ClosePrevFormAsync" />
        </ActionItemTemplate>
    </SortableList>
</div>

@code {
    [Parameter] public int Line { get; set; }
    [Parameter] public bool Focused { get; set; }
    [Parameter] public List<SegmentCreateDto> Segments { get; set; } = new();
    [Parameter] public SegmentCreateDto? EditingSegment { get; set; }
    [Parameter] public EventCallback<List<SegmentCreateDto>> OnSegmentsUpdate { get; set; }
    [Parameter] public EventCallback<List<ChordDto>> OnChordsUpdate { get; set; }
    [Parameter] public EventCallback<SegmentCreateDto?> OnEditingSegmentChanged { get; set; }
    [Parameter] public EventCallback<int> OnFocusLineRequest { get; set; }

    private TabItem? ActiveTab { get; set; }
    private Dictionary<string, Segment> segmentRefs = new();
    private AddSegment addSegmentRef = default!;
    private bool addFormOpen = false;
    private SegmentCreateDto? editSegment;
    private SegmentCreateDto? editedSegment;
    private ChordDto? editedChord;
    private List<SegmentCreateDto> filteredSegments =>
        Segments?.Where(s => s.LineNumber == Line).OrderBy(s => s.LyricOrder).ToList() ?? new();
    private List<int> lineNumbers =>
        Segments.Select(s => s.LineNumber).Distinct().OrderBy(l => l).ToList();
    string textBoxSize => Focused ? "min-height:5rem" : "min-height:4rem";
    private bool showDropdown = false;

    protected override void OnParametersSet()
    {
        if (EditingSegment != null)
        {
            editSegment = EditingSegment;
            editedSegment = editSegment;
        }
    }

    private void SortSegments((int oldIndex, int newIndex) indices)
    {
        var (oldIndex, newIndex) = indices;
        if (oldIndex == newIndex) return;

        var lineSegments = filteredSegments.ToList();
        var itemToMove = lineSegments[oldIndex];
        lineSegments.RemoveAt(oldIndex);

        if (newIndex < lineSegments.Count)
            lineSegments.Insert(newIndex, itemToMove);
        else
            lineSegments.Add(itemToMove);

        for (int i = 0; i < lineSegments.Count; i++)
            lineSegments[i].LyricOrder = i + 1;

        var updatedSegments = Segments.Where(s => s.LineNumber != Line)
                                      .Concat(lineSegments)
                                      .ToList();

        OnSegmentsUpdate.InvokeAsync(updatedSegments);
    }

    private async Task HandleDragStart(SegmentCreateDto segment)
    {
        await JsRt.InvokeVoidAsync("setDragData", "segmentId", segment.Id);
    }

    private async Task HandleDrop()
    {
        var segmentId = await JsRt.InvokeAsync<string>("getDragData", "segmentId");
        var segment = Segments.First(s => s.Id == segmentId);
        segment.LineNumber = Line;

        var maxOrder = filteredSegments.Any() ? filteredSegments.Max(s => s.LyricOrder) : 0;
        segment.LyricOrder = maxOrder + 1;

        await OnSegmentsUpdate.InvokeAsync(Segments);
    }

    private async void HandleDoubleClick(SegmentCreateDto segment)
    {
        await ClosePrevFormAsync();
        if (!string.IsNullOrEmpty(segment.ChordId)
            && !string.IsNullOrEmpty(segment.Id)
            && segmentRefs.ContainsKey(segment.Id))
        {
            var chord = await segmentRefs[segment.Id].GetChord(segment.ChordId);
            if (chord != null) segmentRefs[segment.Id].SetSelectedChord(chord);
        }
        await OnEditingSegmentChanged.InvokeAsync(segment);
    }

    private void HandleSave(SegmentCreateDto segment)
    {
        if (segment != null)
        {
            if (string.IsNullOrWhiteSpace(segment.Lyric) && editedChord == null)
            {
                Segments.RemoveAll(s => s.Id == segment.Id);
                SetAddFormOpen(segment.AddNextSegment);
                return;
            }
            else
            {
                var index = Segments.FindIndex(s => s.Id == segment.Id);
                if (index >= 0)
                    Segments[index] = segment;
            }
            OnSegmentsUpdate.InvokeAsync(Segments);
            SetAddFormOpen(segment.AddNextSegment);
        }
        editSegment = null;
        OnEditingSegmentChanged.InvokeAsync(null);
    }

    private void HandleCancel()
    {
        editSegment = null;
        OnEditingSegmentChanged.InvokeAsync(null);
    }

    public void SetAddFormOpen(bool open)
    {
        addFormOpen = open;
        if (addFormOpen && addSegmentRef != null)
            addSegmentRef.shouldFocusInput = true;
    }

    public async Task ClosePrevFormAsync()
    {
        if (addSegmentRef != null && addSegmentRef.FormOpen)
        {
            await addSegmentRef.SubmitAndExitAsync();
        }
        if (EditingSegment != null 
            && !string.IsNullOrEmpty(EditingSegment.Id)
            && segmentRefs.ContainsKey(EditingSegment.Id))
        {
            await segmentRefs[EditingSegment.Id].HandleEditedAndExitAsync();
        }
    }

    private void HandleSegmentAdded(SegmentCreateDto segment)
    {
        try
        {
            var maxOrder = filteredSegments.Any()
                            ? filteredSegments.Max(s => s.LyricOrder)
                            : 0;
            segment.LyricOrder = maxOrder + 1;
            segment.LineNumber = Line;
            segment.PartNumber = ActiveTab != null ? ActiveTab.SectionNumber : 1;
            segment.PartName = ActiveTab != null ? ActiveTab.SectionEnumValue : SongSection.Verse;

            Segments.Add(segment);
            OnSegmentsUpdate.InvokeAsync(Segments);
            SetAddFormOpen(segment.AddNextSegment);
        }
        catch (Exception ex)
        {
            _logger.LogError("Error adding segment: {Error}", ex);
        }       
    }

    private void HandleSegmentRemoved(SegmentCreateDto segment)
    {
        if (segment != null)
        {
            if (!string.IsNullOrEmpty(segment.Id))
            {
                Segments.RemoveAll(s => s.Id == segment.Id);
                OnSegmentsUpdate.InvokeAsync(Segments);
            }          
        }     
    }

    private void HandleActionConfirmed(LineActionDto lineArgs)
    {
        switch (lineArgs.Action)
        {
            case LineAction.Move:
                MoveLine(lineArgs.CurrentLine, lineArgs.TargetLine);
                break;
            case LineAction.Switch:
                SwitchLine(lineArgs.CurrentLine, lineArgs.TargetLine);
                break;
            case LineAction.Relocate:
                //MoveLine(lineArgs.CurrentLine, lineArgs.TargetLine);
                break;
            default:
                break;
        }
    }

    private void MoveLine(int currentLine, int targetLine)
    {
        if (targetLine == Line) return;
        var updated = Segments.ToList();

        var movedSegments = updated.Where(s => s.LineNumber == currentLine).ToList();

        if (targetLine > currentLine)
        {
            // Shift lines between (currentLine+1 ... targetLine) up by 1
            foreach (var seg in updated.Where(s => s.LineNumber > currentLine && s.LineNumber <= targetLine))
                seg.LineNumber--;
        }
        else
        {
            // Shift lines between (targetLine ... currentLine-1) down by 1
            foreach (var seg in updated.Where(s => s.LineNumber >= targetLine && s.LineNumber < currentLine))
                seg.LineNumber++;
        }

        foreach (var seg in movedSegments)
            seg.LineNumber = targetLine;

        OnSegmentsUpdate.InvokeAsync(updated);
        OnFocusLineRequest.InvokeAsync(targetLine);
    }

    private void SwitchLine(int currentLine, int targetLine)
    {
        if (targetLine == Line) return;

        var updated = Segments.ToList();

        var currSegments = updated.Where(s => s.LineNumber == currentLine).ToList();
        var targetSegments = updated.Where(s => s.LineNumber == targetLine).ToList();

        foreach (var seg in currSegments) seg.LineNumber = targetLine;
        foreach (var seg in targetSegments) seg.LineNumber = currentLine;

        OnSegmentsUpdate.InvokeAsync(updated);
        OnFocusLineRequest.InvokeAsync(targetLine);
    }

    private async void ToggleDropdown(bool show)
    {
        await ClosePrevFormAsync();
        showDropdown = show;
    }

    private async void HandleVisbileChanged(bool visible)
    {
        showDropdown = visible;
        await InvokeAsync(StateHasChanged);
    }

}