@using FRELODYSHRD.Dtos.EditDtos
@inject ILogger<Row> _logger

<div tabindex="0" 
     class="@($"w-100 position-relative d-flex flex-wrap gap-3 bg-white" + 
            $" {(Focused ? "border border-primary" : "border border-secondary")}")"
     style="@(Focused ? "padding:2.5rem" : "padding:1.75rem");border-radius:1rem; border-bottom-right-radius:0.5rem">
    <span class="@($"position-absolute top-0 start-0 badge {(Focused ? "bg-primary mt-2 ms-2" : "mt-1 ms-3")}")">
        Lyric Line @Line.ToString("00")
    </span>

    <SortableList Id="@($"sortable-segments-{Line}")"
                  Items="filteredSegments"
                  OnUpdate="@SortSegments"
                  Context="segment"
                  Class="d-flex flex-wrap w-100 gap-1"
                  Style="@textBoxSize">
        <SortableItemTemplate>
            <div @ondblclick="() => HandleDoubleClick(segment)">
                <Segment @ref="segmentRef"
                         Content="segment"
                         Editing="@(EditingSegment?.Id == segment.Id)"
                         FocusedLine="Focused"
                         TextBoxSize="@textBoxSize"
                         OnSave="HandleSave"
                         OnCancel="HandleCancel"
                         OnDragStart="HandleDragStart" 
                         SegmentRemoved="HandleSegmentRemoved" />
                          
            </div>
        </SortableItemTemplate>
        <ActionItemTemplate>
            @* <DropIndicator LineNumber="Line" /> *@
            
            <AddSegment @ref="addSegmentRef"
                        @bind-FormOpen="addFormOpen"
                        OnSegmentAdded="HandleSegmentAdded"
                        TextBoxSize="@textBoxSize"
                        FocusedLine="Focused" />
        </ActionItemTemplate>
    </SortableList>
</div>

@code {
    [Parameter] public int Line { get; set; }
    [Parameter] public bool Focused { get; set; }
    [Parameter] public List<SegmentCreateDto> Segments { get; set; } = new();
    [Parameter] public SegmentCreateDto? EditingSegment { get; set; }
    [Parameter] public EventCallback<List<SegmentCreateDto>> OnSegmentsUpdate { get; set; }
    [Parameter] public EventCallback<List<ChordDto>> OnChordsUpdate { get; set; }
    [Parameter] public EventCallback<SegmentCreateDto?> OnEditingSegmentChanged { get; set; }
    [Parameter] public TabsComponent.TabsComponentItem? ActiveTab { get; set; }

    private Segment segmentRef = default!;
    private AddSegment addSegmentRef = default!;
    private bool addFormOpen = false;
    private SegmentCreateDto? editSegment;
    private SegmentCreateDto? editedSegment;
    private ChordDto? editedChord;
    private List<SegmentCreateDto> filteredSegments =>
        Segments?.Where(s => s.LineNumber == Line).OrderBy(s => s.LyricOrder).ToList() ?? new();
    string textBoxSize => Focused ? "min-height:5rem" : "min-height:4rem";
    private bool isInitialized = false;

    protected override void OnParametersSet()
    {
        if (EditingSegment != null)
        {
            editSegment = EditingSegment;
            editedSegment = editSegment;
            // editedChord remains for future chord sync if needed
        }
    }

    private void SortSegments((int oldIndex, int newIndex) indices)
    {
        var (oldIndex, newIndex) = indices;

        if (oldIndex == newIndex) return;

        var lineSegments = filteredSegments.ToList();
        var itemToMove = lineSegments[oldIndex];
        lineSegments.RemoveAt(oldIndex);

        if (newIndex < lineSegments.Count)
        {
            lineSegments.Insert(newIndex, itemToMove);
        }
        else
        {
            lineSegments.Add(itemToMove);
        }

        for (int i = 0; i < lineSegments.Count; i++)
        {
            lineSegments[i].LyricOrder = i + 1;
        }

        var updatedSegments = Segments.Where(s => s.LineNumber != Line)
                                    .Concat(lineSegments)
                                    .ToList();

        OnSegmentsUpdate.InvokeAsync(updatedSegments);
    }

    private async Task HandleDragStart(SegmentCreateDto segment)
    {
        await JsRt.InvokeVoidAsync("setDragData", "segmentId", segment.Id);
    }

    private void HandleDragOver()
    {
    }

    private void HandleDragLeave()
    {
    }

    private async Task HandleDrop()
    {
        var segmentId = await JsRt.InvokeAsync<string>("getDragData", "segmentId");
        var segment = Segments.First(s => s.Id == segmentId);
        segment.LineNumber = Line;

        var maxOrder = filteredSegments.Any() ? filteredSegments.Max(s => s.LyricOrder) : 0;
        segment.LyricOrder = maxOrder + 1;

        await OnSegmentsUpdate.InvokeAsync(Segments);
    }

    private async void HandleDoubleClick(SegmentCreateDto segment)
    {
        if (editSegment != null)
        {
            HandleSave(segment);
        }
        if (segmentRef != null && !string.IsNullOrEmpty(segment.ChordId))
        {
            var chord = await segmentRef.GetChord(segment.ChordId);
            if (chord != null) segmentRef.SetSelectedChord(chord);
        }
        await OnEditingSegmentChanged.InvokeAsync(segment);
    }

    private void HandleSave(SegmentCreateDto segment)
    {
        if (segment != null)
        {
            if (string.IsNullOrWhiteSpace(segment.Lyric) && editedChord == null)
            {
                Segments.RemoveAll(s => s.Id == segment.Id);
                SetAddFormOpen(segment.AddNextSegment);
                return;
            }
            else
            {
                var index = Segments.FindIndex(s => s.Id == segment.Id);
                if (index >= 0)
                {
                    Segments[index] = segment;
                }
            }
            OnSegmentsUpdate.InvokeAsync(Segments);
            SetAddFormOpen(segment.AddNextSegment);
        }
        editSegment = null;
        OnEditingSegmentChanged.InvokeAsync(null);
    }

    private void HandleCancel()
    {
        editSegment = null;
        OnEditingSegmentChanged.InvokeAsync(null);
    }

    public void SetAddFormOpen(bool open)
    {
        addFormOpen = open;
        if (addFormOpen && addSegmentRef != null)
        {
            addSegmentRef.shouldFocusInput = true;
        }
    }

    public void ClosePrevForm(int line)
    {
        if (addSegmentRef != null)
        {
            if (addSegmentRef.FormOpen)
                addSegmentRef.SubmitAndExit();
        }
        if (segmentRef != null)
        {
            if (segmentRef.Editing)
            {
                segmentRef.HandleEditedAndExit();
            }            
        }
    }

    private void HandleSegmentAdded(SegmentCreateDto segment)
    {
        try
        {
            var maxOrder = filteredSegments.Any()
                            ? filteredSegments.Max(s => s.LyricOrder)
                            : 0;
            segment.LyricOrder = maxOrder + 1;
            segment.LineNumber = Line;
            segment.PartNumber = ActiveTab != null
                                    ? ActiveTab.SectionNumber
                                    : 1;
            segment.PartName = ActiveTab != null
                                    ? ActiveTab.SectionEnumValue
                                    : SongSection.Verse;

            Segments.Add(segment);
            OnSegmentsUpdate.InvokeAsync(Segments);
            SetAddFormOpen(segment.AddNextSegment);
        }
        catch (Exception ex)
        {
            _logger.LogError("Error adding segment: {Error}", ex);
        }       
    }

    private void HandleSegmentRemoved(SegmentCreateDto segment)
    {
        if (segment != null)
        {
            if (!string.IsNullOrEmpty(segment.Id))
            {
                Segments.RemoveAll(s => s.Id == segment.Id);
                OnSegmentsUpdate.InvokeAsync(Segments);
            }          
        }     
    }

}