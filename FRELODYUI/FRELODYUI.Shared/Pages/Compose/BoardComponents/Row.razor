@using FRELODYSHRD.Dtos.EditDtos
@inject ILogger<Row> _logger

<div tabindex="0" 
     class="@($"w-100 position-relative d-flex flex-wrap gap-3 bg-light" + 
            $" {(Focused ? "border border-primary" : "border border-secondary")}")"
     style="@(Focused ? "padding:2.5rem" : "padding:1.75rem");border-radius:1rem; border-bottom-right-radius:0.5rem">
    <div class="@($"position-absolute top-0 start-0 badge badge-sm {(Focused ? "bg-primary mt-2 ms-2" : "border-secondary opacity-50 mt-1 ms-2")}")">
        Lyric Line @Line.ToString("00")
        @if (Focused)
        {
            <i class="bi bi-chevron-down ms-2" @onclick="() => ToggleDropdown(!showDropdown)"></i>
            @if (showDropdown)
            {
                <RowActions Visible="@showDropdown"
                            CurrentLine="Line" 
                            AllLines="lineNumbers"
                            VisibleChanged="HandleVisbileChanged"
                            OnActionConfirmed="HandleActionConfirmed"/>
            }
        }
    </div>

    <SortableList Id="@($"sortable-segments-{Line}")"
                  Items="filteredSegments"
                  OnUpdate="@SortSegments"
                  Context="segment"
                  OnDropToRemove="@HandleDropToRemove" 
                  Class="d-flex flex-wrap w-100 gap-1"
                  Style="@textBoxSize"
                  OnRemove="@HandleCrossRowMove">
        <SortableItemTemplate>
            <div data-id="@segment.Id" @ondblclick="() => HandleDoubleClick(segment)">
                <Segment @ref="segmentRefs[segment.Id]"
                         Content="segment"
                         Editing="@(EditingSegment?.Id == segment.Id)"
                         FocusedLine="Focused"
                         ShowAlignment="@(activeAlignmentSegmentId == segment.Id)"
                         TextBoxSize="@textBoxSize"
                         OnSave="HandleSave"
                         OnCancel="HandleCancel"
                         OnDragStart="HandleDragStart" 
                         OnAlignmentToggle="HandleAlignmentToggle"
                         SegmentRemoved="HandleSegmentRemoved" />
            </div>
        </SortableItemTemplate>
        <ActionItemTemplate>
            <AddSegment @ref="addSegmentRef"
                        @bind-FormOpen="addFormOpen"
                        OnSegmentAdded="HandleSegmentAdded"
                        TextBoxSize="@textBoxSize"
                        FocusedLine="Focused"
                        OnCancel="HandleCancel"
                        ClosePrevForm="ClosePrevFormAsync" />
        </ActionItemTemplate>
    </SortableList>
</div>

@code {
    [Parameter] public int Line { get; set; }
    [Parameter] public bool Focused { get; set; }
    [Parameter] public List<SegmentCreateDto> Segments { get; set; } = new();
    [Parameter] public SegmentCreateDto? EditingSegment { get; set; }
    [Parameter] public EventCallback<List<SegmentCreateDto>> OnSegmentsUpdate { get; set; }
    [Parameter] public EventCallback<List<ChordDto>> OnChordsUpdate { get; set; }
    [Parameter] public EventCallback<SegmentCreateDto?> OnEditingSegmentChanged { get; set; }
    [Parameter] public EventCallback<int> OnFocusLineRequest { get; set; }
    [Parameter] public EventCallback<string> OnDropToRemove { get; set; }

    private TabItem? ActiveTab { get; set; }
    private Dictionary<string, Segment> segmentRefs = new();
    private AddSegment addSegmentRef = default!;
    private bool addFormOpen = false;
    private SegmentCreateDto? editSegment;
    private SegmentCreateDto? editedSegment;
    private ChordDto? editedChord;
    private string? activeAlignmentSegmentId = null; 
    private List<SegmentCreateDto> filteredSegments =>
        Segments?.Where(s => s.LineNumber == Line).OrderBy(s => s.LyricOrder).ToList() ?? new();
    private List<int> lineNumbers =>
        Segments.Select(s => s.LineNumber).Distinct().OrderBy(l => l).ToList();
    string textBoxSize => Focused ? "min-height:5rem" : "min-height:4rem";
    private bool showDropdown = false;

    protected override void OnParametersSet()
    {
        if (EditingSegment != null)
        {
            editSegment = EditingSegment;
            editedSegment = editSegment;
        }

        // Reset alignment controls when row loses focus
        if (!Focused)
        {
            activeAlignmentSegmentId = null;
        }
    }

    private void HandleAlignmentToggle((string segmentId, bool show)e)
    {
        if (e.show)
        {
            // Show alignment for this segment, hide for all others
            activeAlignmentSegmentId = e.segmentId;
        }
        else
        {
            // Hide alignment if this is the currently active segment
            if (activeAlignmentSegmentId == e.segmentId)
            {
                activeAlignmentSegmentId = null;
            }
        }
        StateHasChanged();
    }

    private void SortSegments((int oldIndex, int newIndex) indices)
    {
        var (oldIndex, newIndex) = indices;
        if (oldIndex == newIndex) return;

        var lineSegments = filteredSegments.ToList();
        var itemToMove = lineSegments[oldIndex];
        lineSegments.RemoveAt(oldIndex);

        if (newIndex < lineSegments.Count)
            lineSegments.Insert(newIndex, itemToMove);
        else
            lineSegments.Add(itemToMove);

        for (int i = 0; i < lineSegments.Count; i++)
            lineSegments[i].LyricOrder = i + 1;

        var updatedSegments = Segments.Where(s => s.LineNumber != Line)
                                      .Concat(lineSegments)
                                      .ToList();

        OnSegmentsUpdate.InvokeAsync(updatedSegments);
    }

    private async Task HandleDragStart(SegmentCreateDto segment)
    {
        // Hide alignment controls when dragging starts
        activeAlignmentSegmentId = null;
        await JsRt.InvokeVoidAsync("setDragData", "segmentId", segment.Id);
    }

    private async Task HandleDrop()
    {
        var segmentId = await JsRt.InvokeAsync<string>("getDragData", "segmentId");
        var segment = Segments.First(s => s.Id == segmentId);
        segment.LineNumber = Line;

        var maxOrder = filteredSegments.Any() ? filteredSegments.Max(s => s.LyricOrder) : 0;
        segment.LyricOrder = maxOrder + 1;

        await OnSegmentsUpdate.InvokeAsync(Segments);
    }

    private async void HandleDoubleClick(SegmentCreateDto segment)
    {
        // Hide alignment controls when entering edit mode
        activeAlignmentSegmentId = null;
        
        await ClosePrevFormAsync();
        if (!string.IsNullOrEmpty(segment.ChordId)
            && !string.IsNullOrEmpty(segment.Id)
            && segmentRefs.ContainsKey(segment.Id))
        {
            var chord = await segmentRefs[segment.Id].GetChord(segment.ChordId);
            if (chord != null) segmentRefs[segment.Id].SetSelectedChord(chord);
        }
        await OnEditingSegmentChanged.InvokeAsync(segment);
    }

    private void HandleSave(SegmentCreateDto segment)
    {
        if (segment != null)
        {
            if (string.IsNullOrWhiteSpace(segment.Lyric) && editedChord == null)
            {
                Segments.RemoveAll(s => s.Id == segment.Id);
                SetAddFormOpen(segment.AddNextSegment);
                return;
            }
            else
            {
                var index = Segments.FindIndex(s => s.Id == segment.Id);
                if (index >= 0)
                    Segments[index] = segment;
            }
            OnSegmentsUpdate.InvokeAsync(Segments);
            SetAddFormOpen(segment.AddNextSegment);
        }
        editSegment = null;
        OnEditingSegmentChanged.InvokeAsync(null);
    }

    private void HandleCancel()
    {
        editSegment = null;
        OnEditingSegmentChanged.InvokeAsync(null);
    }

    public void SetAddFormOpen(bool open)
    {
        addFormOpen = open;
        if (addFormOpen && addSegmentRef != null)
            addSegmentRef.shouldFocusInput = true;
    }

    public async Task ClosePrevFormAsync()
    {
        // Hide alignment controls when closing forms
        activeAlignmentSegmentId = null;
        
        if (addSegmentRef != null && addSegmentRef.FormOpen)
        {
            await addSegmentRef.SubmitAndExitAsync();
        }
        if (EditingSegment != null 
            && !string.IsNullOrEmpty(EditingSegment.Id)
            && segmentRefs.ContainsKey(EditingSegment.Id))
        {
            await segmentRefs[EditingSegment.Id].HandleEditedAndExitAsync();
        }
    }

    private void HandleSegmentAdded(SegmentCreateDto segment)
    {
        try
        {
            var maxOrder = filteredSegments.Any()
                            ? filteredSegments.Max(s => s.LyricOrder)
                            : 0;
            segment.LyricOrder = maxOrder + 1;
            segment.LineNumber = Line;
            segment.PartNumber = ActiveTab != null ? ActiveTab.SectionNumber : 1;
            segment.PartName = ActiveTab != null ? ActiveTab.SectionEnumValue : SongSection.Verse;

            Segments.Add(segment);
            OnSegmentsUpdate.InvokeAsync(Segments);
            SetAddFormOpen(segment.AddNextSegment);
        }
        catch (Exception ex)
        {
            _logger.LogError("Error adding segment: {Error}", ex);
        }       
    }

    private void HandleSegmentRemoved(SegmentCreateDto segment)
    {
        if (segment != null)
        {
            if (!string.IsNullOrEmpty(segment.Id))
            {
                // Hide alignment if this segment was showing it
                if (activeAlignmentSegmentId == segment.Id)
                {
                    activeAlignmentSegmentId = null;
                }
                
                Segments.RemoveAll(s => s.Id == segment.Id);
                OnSegmentsUpdate.InvokeAsync(Segments);
            }          
        }     
    }

    private void HandleActionConfirmed(LineActionDto lineArgs)
    {
        switch (lineArgs.Action)
        {
            case LineAction.Move:
                MoveLine(lineArgs.CurrentLine, lineArgs.TargetLine);
                break;
            case LineAction.Switch:
                SwitchLine(lineArgs.CurrentLine, lineArgs.TargetLine);
                break;
            case LineAction.Duplicate:
                DuplicateLine(lineArgs.CurrentLine, lineArgs.TargetLine);
                break;
            case LineAction.Relocate:
                //MoveLine(lineArgs.CurrentLine, lineArgs.TargetLine);
                break;
            default:
                break;
        }
    }

    private void MoveLine(int currentLine, int targetLine)
    {
        if (targetLine == Line) return;
        var updated = Segments.ToList();

        var movedSegments = updated.Where(s => s.LineNumber == currentLine).ToList();

        if (targetLine > currentLine)
        {
            // Shift lines between (currentLine+1 ... targetLine) up by 1
            foreach (var seg in updated.Where(s => s.LineNumber > currentLine && s.LineNumber <= targetLine))
                seg.LineNumber--;
        }
        else
        {
            // Shift lines between (targetLine ... currentLine-1) down by 1
            foreach (var seg in updated.Where(s => s.LineNumber >= targetLine && s.LineNumber < currentLine))
                seg.LineNumber++;
        }

        foreach (var seg in movedSegments)
            seg.LineNumber = targetLine;

        OnSegmentsUpdate.InvokeAsync(updated);
        OnFocusLineRequest.InvokeAsync(targetLine);
    }

    private void SwitchLine(int currentLine, int targetLine)
    {
        if (targetLine == Line) return;

        var updated = Segments.ToList();

        var currSegments = updated.Where(s => s.LineNumber == currentLine).ToList();
        var targetSegments = updated.Where(s => s.LineNumber == targetLine).ToList();

        foreach (var seg in currSegments) seg.LineNumber = targetLine;
        foreach (var seg in targetSegments) seg.LineNumber = currentLine;

        OnSegmentsUpdate.InvokeAsync(updated);
        OnFocusLineRequest.InvokeAsync(targetLine);
    }

    private void DuplicateLine(int currentLine, int afterLine)
    {
        var updated = Segments.ToList();

        // Get all segments from the current line
        var sourceSegments = updated
            .Where(s => s.LineNumber == currentLine)
            .OrderBy(s => s.LyricOrder)
            .ToList();

        if (!sourceSegments.Any()) return;

        // Shift lines after afterLine down by 1 to make room
        foreach (var seg in updated.Where(s => s.LineNumber > afterLine))
            seg.LineNumber++;

        // Create duplicated segments
        var duplicatedSegments = sourceSegments.Select(seg => new SegmentCreateDto
        {
            Id = Guid.NewGuid().ToString(),
            Lyric = seg.Lyric,
            ChordId = seg.ChordId,
            ChordName = seg.ChordName,
            ChordAlignment = seg.ChordAlignment,
            LineNumber = afterLine + 1,
            PartNumber = seg.PartNumber,
            PartName = seg.PartName,
            LyricOrder = seg.LyricOrder,
            AddNextSegment = false
        }).ToList();

        // Add duplicated segments to the updated list
        updated.AddRange(duplicatedSegments);

        OnSegmentsUpdate.InvokeAsync(updated);
        OnFocusLineRequest.InvokeAsync(afterLine + 1);
    }

    private async void ToggleDropdown(bool show)
    {
        // Hide alignment controls when dropdown is toggled
        activeAlignmentSegmentId = null;
        await ClosePrevFormAsync();
        showDropdown = show;
    }

    public async void HandleVisbileChanged(bool visible)
    {
        showDropdown = visible;
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleDropToRemove(string segmentId)
    {
        if (OnDropToRemove.HasDelegate)
        {
            await OnDropToRemove.InvokeAsync(segmentId);
        }
    }

    private void HandleCrossRowMove((int oldIndex, int newIndex, string? toId) args)
    {
        if (args.toId == null) return;  // Not cross-row

        var targetLine = int.Parse(args.toId.Replace("sortable-segments-", ""));
        if (targetLine == Line)  // Same row, treat as update
        {
            SortSegments((args.oldIndex, args.newIndex));
            return;
        }

        // Get moving segment
        var movingSegment = filteredSegments[args.oldIndex];

        // Remove from source and renumber
        filteredSegments.RemoveAt(args.oldIndex);
        for (int i = 0; i < filteredSegments.Count; i++)
            filteredSegments[i].LyricOrder = i + 1;

        // Update global Segments (replace with updated source segments)
        var updatedSegments = Segments.Where(s => s.LineNumber != Line)
                                      .Concat(filteredSegments)
                                      .ToList();

        // Add to target: Insert at newIndex with updated LineNumber and LyricOrder
        movingSegment.LineNumber = targetLine;
        movingSegment.LyricOrder = args.newIndex + 1;  // 1-based

        // To insert properly, we'd ideally fetch target's current segments and insert,
        // but since Segments is global, add it and sort/renumber all for target line
        updatedSegments.Add(movingSegment);

        // Renumber target line's orders
        var targetSegments = updatedSegments.Where(s => s.LineNumber == targetLine)
                                            .OrderBy(s => s.LyricOrder).ToList();
        for (int i = 0; i < targetSegments.Count; i++)
            targetSegments[i].LyricOrder = i + 1;

        // Update global with renumbered target
        updatedSegments = updatedSegments.Where(s => s.LineNumber != targetLine)
                                          .Concat(targetSegments).ToList();

        OnSegmentsUpdate.InvokeAsync(updatedSegments);
        OnFocusLineRequest.InvokeAsync(targetLine);  // Focus the target row
    }
}