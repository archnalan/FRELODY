@inject ILogger<SongSectionBoard> _logger

<div class="h-100 w-100 bg-body text-dark overflow-auto">
    @if (lines.Count > 0)
    {
        <p class="small ms-3 mt-3 mb-0">Each segment can be assigned a chord.</p>
    }
    else
    {
        <p class="text-muted small ms-3 mt-3 mb-0">Click the button below to add a new line.</p>
    }

    <div class="d-flex align-items-center w-100 mb-3">
        <div class="@($"flex-grow-1 h-0 border border-dashed ms-3 {(lines.Count > 0 ? "bg-secondary opacity-50" : "border-primary")}")"></div>
        <button class="@($"btn btn-sm {(lines.Count > 0 ? "btn-outline-secondary" : "btn-outline-primary")}")"
                disabled="@(lines.Count > 0)"
                @onclick="async () => await AddLine(0)">
            <i class="bi bi-plus"></i>
            <span class="small">New Line</span>
        </button>
        <div class="@($"flex-grow-1 h-0 border border-dashed me-3 {(lines.Count > 0 ? "bg-secondary opacity-50" : "border-primary")}")"></div>
    </div>

    @foreach (var line in lines)
    {
        <div class="position-relative mb-3" id="@($"line-{line}")" @onmousedown="async () => await SetFocusedRow(line)">
            <Row @ref="lineRefs[line]"
                 Line="@line"
                 Focused="@(focusedRow == line)"
                 Segments="@Segments"
                 EditingSegment="@editingSegment"
                 OnSegmentsUpdate="HandleSegmentsUpdate"
                 OnChordsUpdate="HandleChordsUpdate"
                 OnEditingSegmentChanged="HandleEditingSegmentChanged"
                 OnFocusLineRequest="HandleFocusLineRequested"/>

            @if (focusedRow == line)
            {
                <div class="position-absolute bottom-0 end-0 mb-2 me-2">
                    <button class="btn btn-sm btn-outline-primary rounded-top-0 rounded-end-0"
                            @onclick="async () => await AddLine(line)">
                        <i class="bi bi-plus"></i>
                        <span class="small text-primary">New Line</span>
                    </button>
                    <button class="@($"btn btn-sm btn-outline-danger rounded-top-0 rounded-start-0 {(isOver ? "bg-danger text-white" : "")}")"
                            id="@($"remove-button-{line}")"
                            data-line="@line">
                        <i class="bi bi-fire"></i>
                        <span class="small">Remove</span>
                    </button>
                </div>
            }

        </div>
    }

    @if (lines.Count > 0)
    {
        <div class="text-muted small text-end">
            Verse @SectionId • Lines: @lines.Count • Segments: @Segments?.Count
        </div>
    }
</div>

<DialogModal IsVisible="@_modalService.IsModalVisible"
               Modal="@_modalService.CurrentModal"
               OnConfirmModal="ConfirmModal"
               OnCloseModal="CloseModal" />

@code {
    [Parameter] public int SectionId { get; set; }
    [Parameter] public List<SegmentCreateDto>? Segments { get; set; } = new();
    [Parameter] public EventCallback<List<SegmentCreateDto>> OnSegmentsUpdate { get; set; }
    [Parameter] public TabItem? ActiveTab { get; set; } 
    private List<ChordDto> chords = new();
    private Dictionary<int, Row> lineRefs = new();
    private int? focusedRow = null;
    private List<int> trackLines = new();
    private List<int> lines = new();
    private SegmentCreateDto? editingSegment = null;
    private bool isOver = false;
    private int lineToDelete;
    private DotNetObjectReference<SongSectionBoard>? selfRef;
    private int prevLinesCount;
    private int? prevFocusedRow;
    private IJSObjectReference? _module;
    private async Task HandleFocusLineRequested(int line)
        => await SetFocusedRow(line);

    protected override void OnInitialized()
    {
        try
        {
            if(Segments == null)
                Segments = new List<SegmentCreateDto>();

            trackLines = Segments
            .Where(s => s.PartName == SongSection.Verse 
                && s.PartNumber == SectionId)
            .Select(s => s.LineNumber)
            .Distinct()
            .ToList();

            UpdateLines();
            if (lines.Count > 0) focusedRow = lines[0];

            _tabsManager.OnRemoveEmptyLine += HandleRemoveEmptyLineRequest;
            _tabsManager.OnAddLineToSection += HandleAddLineToSection;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            _logger.LogError("Error initializing SongSectionBoard: {Error}",ex);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        try
        {
            if (firstRender)
            {
                _module = await JsRt.InvokeAsync<IJSObjectReference>("import", "./_content/FRELODYUI.Shared/Pages/Compose/SongSectionBoard.razor.js");
                selfRef = DotNetObjectReference.Create(this);
                await _module.InvokeVoidAsync("initRemoveZones", selfRef);
                prevLinesCount = lines.Count;
                prevFocusedRow = focusedRow;
            }
            else
            {
                bool linesChanged = lines.Count != prevLinesCount;
                bool focusChanged = focusedRow != prevFocusedRow;

                if (linesChanged || focusChanged)
                {
                    _module ??= await JsRt.InvokeAsync<IJSObjectReference>("import", "./_content/FRELODYUI.Shared/Pages/Compose/SongSectionBoard.razor.js");
                    await _module.InvokeVoidAsync("initRemoveZones", selfRef);
                    prevLinesCount = lines.Count;
                    prevFocusedRow = focusedRow;
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError("Error running OnAfterRenderAsync: {Error}", ex);
        }
    }

    public void RemoveEmptyLine(int lineNumber)
    {
        bool wasTracked = trackLines.Remove(lineNumber);

        var hasSegments = Segments?.Any(s => s.LineNumber == lineNumber) ?? false;

        if (wasTracked || !hasSegments)
        {
            UpdateLines();

            if (focusedRow == lineNumber)
            {
                focusedRow = lines.Count > 0 ? lines[0] : null;
            }

            StateHasChanged();
        }
    }

    private void UpdateLines()
    {
        var segmentLines = Segments?
                        .Select(s => s.LineNumber)
                        .Distinct()
                        .ToList() ?? new List<int>();

        var validTrackLines = trackLines
            .Where(tl => Segments?.Any(s => s.LineNumber == tl) == true)
            .ToList();

        lines = segmentLines
                .Union(validTrackLines)
                .Distinct()
                .OrderBy(l => l)
                .ToList();

        trackLines = validTrackLines;

        PruneRowRefs();
    }
    private async Task HandleRemoveEmptyLineRequest(int sectionId, int lineNumber)
    {
        if (sectionId == SectionId)
        {
            RemoveEmptyLine(lineNumber);
            await Task.CompletedTask;
        }
    }

    private async Task HandleAddLineToSection(int sectionId, int afterLine, List<SegmentCreateDto>? segments = null)
    {
        if (sectionId == SectionId)
        {
            bool lineAdded = false;
            if (!lineAdded)
            {
                await AddLine(afterLine, segments);
                lineAdded = true;
            }
        }        
    }

    private void PruneRowRefs()
    {
        var valid = new HashSet<int>(lines);
        var stale = lineRefs.Keys.Where(k => !valid.Contains(k)).ToList();
        foreach (var k in stale)
            lineRefs.Remove(k);
    }

    private Row? TryGetRowRef(int line)
    {
        return lineRefs.TryGetValue(line, out var row) ? row : null;
    }

    private void HandleSegmentsUpdate(List<SegmentCreateDto> updatedSegments)
    {
        Segments = updatedSegments;
        UpdateLines();
        OnSegmentsUpdate.InvokeAsync(Segments.Select(s =>
        {
            s.PartNumber = SectionId;
            return s;
        }).ToList());
    }

    private void HandleChordsUpdate(List<ChordDto> updatedChords)
    {
        chords = updatedChords;
    }

    private void HandleEditingSegmentChanged(SegmentCreateDto? segment)
    {
        editingSegment = segment;
    }

    private async Task SetFocusedRow(int line)
    {
        if (focusedRow.HasValue && focusedRow != line)
        {
            var prev = TryGetRowRef(focusedRow.Value);
            if (prev is not null)
                await prev.ClosePrevFormAsync();
            var curr = TryGetRowRef(line);
            if (curr is not null)
                curr.HandleVisbileChanged(false);//close dropdown if open
        }
        focusedRow = line;
        StateHasChanged(); // ensure remove button renders before init in next render pass
    }

    public async Task AddLine(int afterLine, List<SegmentCreateDto>? segmentsToAdd = null)
    {
        try
        {
            var prev = TryGetRowRef(afterLine);
            if (prev is not null)
                await prev.ClosePrevFormAsync();

            var lineIndex = lines.IndexOf(afterLine);
            int tempLineId = -1 * (trackLines.Count + 1);

            var newSegments = new List<SegmentCreateDto>();

            // Add provided segments first (if any)
            if (segmentsToAdd != null && segmentsToAdd.Count > 0)
            {
                foreach (var segment in segmentsToAdd)
                {
                    segment.LineNumber = tempLineId;
                    segment.PartNumber = ActiveTab != null ? ActiveTab.SectionNumber : SectionId;
                    segment.PartName = ActiveTab != null ? ActiveTab.SectionEnumValue : SongSection.Verse;
                    newSegments.Add(segment);
                }
            }

            // Anew empty segment at the end for editing
            var newSegmentId = Guid.NewGuid().ToString();
            var emptySegment = new SegmentCreateDto
            {
                Id = newSegmentId,
                Lyric = "",
                LineNumber = tempLineId,
                PartNumber = ActiveTab != null ? ActiveTab.SectionNumber : SectionId,
                PartName = ActiveTab != null ? ActiveTab.SectionEnumValue : SongSection.Verse,
                LyricOrder = newSegments.Count + 1 // Position after any provided segments
            };
            newSegments.Add(emptySegment);

            Segments?.AddRange(newSegments);

            if (lineIndex >= 0 && lineIndex < trackLines.Count - 1)
                trackLines.Insert(lineIndex + 1, tempLineId);
            else
                trackLines.Add(tempLineId);

            RenumberLines();

            editingSegment = emptySegment;

            if (lineIndex >= 0 && lineIndex + 1 < lines.Count)
                focusedRow = lines[lineIndex + 1];
            else if (lines.Count > 0)
                focusedRow = lines[^1];

            StateHasChanged();
        }
        catch (Exception ex)
        {
            _logger.LogError("Error adding line: {Error}", ex);
        }
    }

    public async Task AddLineWithContent(int afterLine, List<SegmentCreateDto>? segmentsToAdd)
    {
        try
        {
            var prev = TryGetRowRef(afterLine);
            if (prev is not null)
                await prev.ClosePrevFormAsync();

            var lineIndex = lines.IndexOf(afterLine);
            int newLineNumber = lines.Count > 0 ? lines.Max() + 1 : 1;

            foreach (var segment in segmentsToAdd)
            {
                segment.LineNumber = newLineNumber;
                segment.PartNumber = ActiveTab != null ? ActiveTab.SectionNumber : SectionId;
                segment.PartName = ActiveTab != null ? ActiveTab.SectionEnumValue : SongSection.Verse;
                // Keep existing Id, Lyric, ChordId, ChordName, LyricOrder, ChordAlignment
            }

            // Add the segments to the current segments list
            if (Segments != null)
            {
                Segments.AddRange(segmentsToAdd);
            }
            else
            {
                Segments = segmentsToAdd.ToList();
            }

            // Add the new line to trackLines
            trackLines.Add(newLineNumber);

            // Update lines and UI
            UpdateLines();

            // Set focus to the new line
            focusedRow = newLineNumber;

            // Set the first segment as editing if it exists
            if (segmentsToAdd.Any())
            {
                editingSegment = segmentsToAdd.First();
            }

            // Notify parent of the update
            HandleSegmentsUpdate(Segments);

            StateHasChanged();
        }
        catch (Exception ex)
        {
            _logger.LogError("Error adding line with content: {Error}", ex);
        }
    }

    private void RenumberLines()
    {
        try
        {
            var newLineMap = new Dictionary<long, int>();
            for (int i = 0; i < trackLines.Count; i++)
                newLineMap[trackLines[i]] = i + 1;

            Segments = Segments?.Select(s =>
            {
                if (newLineMap.ContainsKey(s.LineNumber))
                    s.LineNumber = newLineMap[s.LineNumber];
                return s;
            }).ToList();

            trackLines = trackLines.Select(l => newLineMap.ContainsKey(l) ? newLineMap[l] : l).ToList();
            UpdateLines();
        }
        catch (Exception ex)
        {
            _logger.LogError("Error renumbering lines: {Error}", ex);
        }    
    }

    private void ShowDeleteDialog(int line)
    {
        _modalService.Show(new ModalOptionDto
        {
            Title = "Delete Line",
            SubTitle = "Are you sure you want to delete this line?",
            Message = $"Segments in this line {line.ToString("00")}: will be deleted.",
            DangerText = "This action is irreversible!",
            ButtonText = "Delete",
            OptionType = OptionType.Confirmation,            
            Context = new ModalContext
            {
                ActionType = "DeleteLine",
                Data = line
            }
        });
        StateHasChanged();
    }

    private void DeleteLine(int line)
    {
        Segments?.RemoveAll(s => s.LineNumber == line);
        trackLines.Remove(line);
        RenumberLines();

        focusedRow = trackLines.Count > 0 ? trackLines[0] : null;

        editingSegment = null;
        lineToDelete = 0;
        StateHasChanged();
    }

    private void HandleDragOver() => isOver = true;
    private void HandleDragLeave() => isOver = false;

    [JSInvokable]
    public async Task HandleRemoveDrop(int line, string segmentId)
    {
        var segment = Segments?.FirstOrDefault(s => s.Id == segmentId);
        if (segment != null)
        {
            _modalService.Show(new ModalOptionDto
            {
                Title = "Delete Segment",
                SubTitle = "Are you sure you want to delete this segment?",
                Message = $"The segment with lyric '{segment.Lyric}' will be deleted.",
                DangerText = "This action is irreversible!",
                ButtonText = "OK",
                OptionType = OptionType.Confirmation,
                Context = new ModalContext
                {
                    ActionType = "DeleteSegment",
                    Data = segmentId
                }
            }); 
            StateHasChanged();
        }
    }

    private async Task ConfirmModal()
    {
        if (_modalService.CurrentModal?.Context?.ActionType == "DeleteLine")
        {
            var line = (int)_modalService.CurrentModal.Context.Data!;
            DeleteLine(line);
        }
        else if (_modalService.CurrentModal?.Context?.ActionType == "DeleteSegment")
        {
            var segmentId = _modalService.CurrentModal.Context.Data?.ToString();
            Segments?.RemoveAll(s => s.Id == segmentId);
            if (editingSegment?.Id == segmentId) editingSegment = null;

            // Update everything
            HandleSegmentsUpdate(Segments);  // This updates lines, invokes OnSegmentsUpdate

        }
        await CloseModal();
    }

    private async Task CloseModal()
    {
        await Task.Delay(100);
        _modalService.Close();
        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            _tabsManager.OnRemoveEmptyLine -= HandleRemoveEmptyLineRequest;
            _tabsManager.OnAddLineToSection -= HandleAddLineToSection;
            if (_module is not null)
            {
                await _module.DisposeAsync();
            }
        }
        catch { /* ignore */ }
        finally
        {
            selfRef?.Dispose();
        }
    }
}