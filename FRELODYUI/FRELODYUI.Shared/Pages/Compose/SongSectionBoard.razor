@inject ILogger<SongSectionBoard> _logger

<div class="h-100 w-100 bg-light text-dark overflow-auto">
    @if (lines.Count > 0)
    {
        <p class="small ms-3 mt-3 mb-0">Each segment can be assigned a chord.</p>
    }
    else
    {
        <p class="text-muted small ms-3 mt-3 mb-0">Click the button below to add a new line.</p>
    }

    <div class="d-flex align-items-center w-100 mb-3">
        <div class="@($"flex-grow-1 h-0 border border-dashed ms-3 {(lines.Count > 0 ? "border-secondary opacity-50" : "border-primary")}")"></div>
        <button class="@($"btn btn-sm {(lines.Count > 0 ? "btn-outline-secondary" : "btn-outline-primary")}")"
                disabled="@(lines.Count > 0)"
                @onclick="async () => await AddLine(0)">
            <i class="bi bi-plus"></i>
            <span class="small">New Line</span>
        </button>
        <div class="@($"flex-grow-1 h-0 border border-dashed me-3 {(lines.Count > 0 ? "border-secondary opacity-50" : "border-primary")}")"></div>
    </div>

    @foreach (var line in lines)
    {
        <div class="position-relative mb-3" id="@($"line-{line}")" @onmousedown="async () => await SetFocusedRow(line)">
            <Row @ref="lineRefs[line]"
                 Line="@line"
                 Focused="@(focusedRow == line)"
                 Segments="@Segments"
                 ActiveTab="@ActiveTab"
                 EditingSegment="@editingSegment"
                 OnSegmentsUpdate="HandleSegmentsUpdate"
                 OnChordsUpdate="HandleChordsUpdate"
                 OnEditingSegmentChanged="HandleEditingSegmentChanged" />

            @if (focusedRow == line)
            {
                <div class="position-absolute bottom-0 end-0 mb-2 me-2">
                    <button class="btn btn-sm btn-outline-primary rounded-top-0 rounded-end-0"
                            @onclick="async () => await AddLine(line)">
                        <i class="bi bi-plus"></i>
                        <span class="small text-primary">New Line</span>
                    </button>
                    <button class="@($"btn btn-sm btn-outline-danger rounded-top-0 rounded-start-0 {(isOver ? "bg-danger text-white" : "")}")"
                            @onclick="() => ShowDeleteDialog(line)"
                            @ondragover="HandleDragOver"
                            @ondragleave="HandleDragLeave"
                            @ondrop="e => HandleDrop(e, line)">
                        <i class="bi bi-fire"></i>
                        <span class="small">Remove</span>
                    </button>
                </div>
            }

        </div>
    }

    @if (lines.Count > 0)
    {
        <div class="text-muted small text-end">
            Verse @SectionId • Lines: @lines.Count • Segments: @Segments.Count
        </div>
    }
</div>

@if (showDeleteDialog)
{
    <DialogConfirm ModalTitle="@modalTitle"
                   ModalSubtitle="@modalSubtitle"
                   ModalMessage="@modalMessage"
                   ModalDangerText="@modalDangerText"
                   ModalButtonText="@modalButtonText"
                   OnConfirm="() => DeleteLine(lineToDelete)"
                   OnCancel="CloseDeleteDialog" />
}

@code {
    [Parameter] public int SectionId { get; set; }
    [Parameter] public List<SegmentCreateDto>? Segments { get; set; } = new();
    [Parameter] public EventCallback<List<SegmentCreateDto>> OnSegmentsUpdate { get; set; }
    [Parameter] public TabsComponent.TabsComponentItem? ActiveTab { get; set; } 
    private List<ChordDto> chords = new();
    private Dictionary<int, Row> lineRefs = new();
    private int? focusedRow = null;
    private List<int> trackLines = new();
    private List<int> lines = new();
    private SegmentCreateDto? editingSegment = null;
    private bool isOver = false;
    private string? modalTitle { get; set; }
    private string? modalSubtitle { get; set; }
    private string? modalMessage { get; set; }
    private string? modalDangerText { get; set; }
    private string? modalButtonText { get; set; }
    private bool showDeleteDialog = false;
    private int lineToDelete;

    protected override void OnInitialized()
    {
        try
        {
            trackLines = Segments
            .Where(s => s.PartName == SongSection.Verse 
                && s.PartNumber == SectionId)
            .Select(s => s.LineNumber)
            .Distinct()
            .ToList();

            UpdateLines();
            if (lines.Count > 0) focusedRow = lines[0];
            StateHasChanged();
        }
        catch (Exception ex)
        {
            _logger.LogError("Error initializing SongSectionBoard: {Error}",ex);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JsRt.InvokeVoidAsync("initDragAndDrop");
        }
    }

    private void UpdateLines()
    {
        var segmentLines = Segments?
                        .Select(s => s.LineNumber)
                        .Distinct()
                        .ToList();
        if (segmentLines != null)
        {
            lines = segmentLines
                    .Union(trackLines)
                    .Distinct()
                    .OrderBy(l => l)
                    .ToList();
        }
        PruneRowRefs();
    }

    private void PruneRowRefs()
    {
        var valid = new HashSet<int>(lines);
        var stale = lineRefs.Keys.Where(k => !valid.Contains(k)).ToList();
        foreach (var k in stale)
            lineRefs.Remove(k);
    }

    private Row? TryGetRowRef(int line)
    {
        return lineRefs.TryGetValue(line, out var row) ? row : null;
    }

    private void HandleSegmentsUpdate(List<SegmentCreateDto> updatedSegments)
    {
        Segments = updatedSegments;
        UpdateLines();
        OnSegmentsUpdate.InvokeAsync(Segments.Select(s =>
        {
            s.PartNumber = SectionId;
            return s;
        }).ToList());
    }

    private void HandleChordsUpdate(List<ChordDto> updatedChords)
    {
        chords = updatedChords;
    }

    private void HandleEditingSegmentChanged(SegmentCreateDto? segment)
    {
        editingSegment = segment;
    }

    private async Task SetFocusedRow(int line)
    {
        if (focusedRow.HasValue && focusedRow != line)
        {
            var prev = TryGetRowRef(focusedRow.Value);
            if (prev is not null)
                await prev.ClosePrevFormAsync();
        }
        focusedRow = line;
    }

    private async Task AddLine(int afterLine)
    {
        try
        {
            var prev = TryGetRowRef(afterLine);
            if (prev is not null)
                await prev.ClosePrevFormAsync();

            var lineIndex = lines.IndexOf(afterLine);
            int tempLineId = -1 * (trackLines.Count + 1); 
            var newSegmentId = Guid.NewGuid().ToString();

            var newSegment = new SegmentCreateDto
            {
                Id = newSegmentId,
                Lyric = "",
                LineNumber = tempLineId,
                PartNumber = ActiveTab != null ? ActiveTab.SectionNumber : 1,
                PartName = ActiveTab != null ? ActiveTab.SectionEnumValue : SongSection.Verse,
                LyricOrder = 1
            };
            Segments?.Add(newSegment);

            if (lineIndex >= 0 && lineIndex < trackLines.Count - 1)
                trackLines.Insert(lineIndex + 1, tempLineId);
            else
                trackLines.Add(tempLineId);

            RenumberLines();
            editingSegment = newSegment;

            if (lineIndex >= 0 && lineIndex + 1 < lines.Count)
                focusedRow = lines[lineIndex + 1];
            else if (lines.Count > 0)
                focusedRow = lines[^1];

            StateHasChanged();
        }
        catch (Exception ex)
        {
            _logger.LogError("Error adding line: {Error}", ex);
        }
    }

    private void RenumberLines()
    {
        try
        {
            var newLineMap = new Dictionary<long, int>();
            for (int i = 0; i < trackLines.Count; i++)
                newLineMap[trackLines[i]] = i + 1;

            Segments = Segments?.Select(s =>
            {
                if (newLineMap.ContainsKey(s.LineNumber))
                    s.LineNumber = newLineMap[s.LineNumber];
                return s;
            }).ToList();

            trackLines = trackLines.Select(l => newLineMap.ContainsKey(l) ? newLineMap[l] : l).ToList();
            UpdateLines();
        }
        catch (Exception ex)
        {
            _logger.LogError("Error renumbering lines: {Error}", ex);
        }    
    }

    private void ShowDeleteDialog(int line)
    {
        modalTitle = "Delete Line";
        modalSubtitle = "Are you sure you want to delete this line?";
        modalMessage = $"Segments in this line {line.ToString("00")}: will be deleted.";
        modalDangerText = "This action is irreversible!";
        modalButtonText = "Delete";
        lineToDelete = line;
        showDeleteDialog = true;
    }

    private void CloseDeleteDialog()
    {
        showDeleteDialog = false;
    }

    private void DeleteLine(int line)
    {
        Segments?.RemoveAll(s => s.LineNumber == line);
        trackLines.Remove(line);
        RenumberLines();

        focusedRow = trackLines.Count > 0 ? trackLines[0] : null;

        editingSegment = null;
        showDeleteDialog = false;
        lineToDelete = 0;
    }

    private void HandleDragOver() => isOver = true;
    private void HandleDragLeave() => isOver = false;

    private async Task HandleDrop(DragEventArgs e, int line)
    {
        isOver = false;
        var segmentId = await JsRt.InvokeAsync<string>("getDragData", "segmentId");
        Segments?.RemoveAll(s => s.Id == segmentId);
        if (editingSegment?.Id == segmentId)
            editingSegment = null;
    }
}