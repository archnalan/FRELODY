@inject ILogger<SongSectionBoard> _logger

<div class="h-100 w-100 bg-light text-dark overflow-auto">
    @if (lines.Count > 0)
    {
        <p class="m-0  small">Each segment can be assigned a chord.</p>
    }
    else
    {
        <p class="m-0 text-muted small">Click the button below to add a new line.</p>
    }

    <div class="d-flex align-items-center w-100 mb-3">
        <div class="@($"flex-grow-1 h-0 border border-dashed {(lines.Count > 0 ? "border-secondary" : "border-primary")}")"></div>
        <button class="@($"btn btn-sm {(lines.Count > 0 ? "btn-outline-secondary" : "btn-outline-primary")}")"
                disabled="@(lines.Count > 0)"
                @onclick="() => AddLine(0)">
            <i class="bi bi-plus"></i>
            <span class="small">New Line</span>
        </button>
        <div class="@($"flex-grow-1 h-0 border border-dashed {(lines.Count > 0 ? "border-secondary" : "border-primary")}")"></div>
    </div>

    @foreach (var line in lines)
    {
        <div class="position-relative mb-3" id="@($"line-{line}")">
            <Row Line="@line"
                 Focused="@(focusedRow == line)"
                 Segments="@Segments"
                 Chords="@chords"
                 ActiveTab="@ActiveTab"
                 EditModeSegmentId="@editModeSegmentId"
                 OnFocusRow="() => SetFocusedRow(line)"
                 OnSegmentsUpdate="HandleSegmentsUpdate"
                 OnChordsUpdate="HandleChordsUpdate"
                 OnEditModeSegmentIdChanged="HandleEditModeSegmentIdChanged" />

            @if (focusedRow == line)
            {
                <div class="position-absolute bottom-0 end-0 mb-2 me-2">
                    <button class="btn btn-sm btn-outline-primary rounded-top-0 rounded-end-0"
                            @onclick="() => AddLine(line)">
                        <i class="bi bi-plus"></i>
                        <span class="small text-primary">New Line</span>
                    </button>
                    <button class="@($"btn btn-sm btn-outline-danger rounded-top-0 rounded-start-0 {(isOver ? "bg-danger text-white" : "")}")"
                            @onclick="() => ShowDeleteDialog(line)"
                            @ondragover="HandleDragOver"
                            @ondragleave="HandleDragLeave"
                            @ondrop="e => HandleDrop(e, line)">
                        <i class="bi bi-fire"></i>
                        <span class="small">Remove</span>
                    </button>
                </div>
            }

        </div>
    }

    @if (lines.Count > 0)
    {
        <div class="text-muted small text-end">
            Verse @SectionId • Lines: @lines.Count • Segments: @Segments.Count
        </div>
    }
</div>

@if (showDeleteDialog)
{
    <DialogConfirm ModalTitle="@modalTitle"
                   ModalSubtitle="@modalSubtitle"
                   ModalMessage="@modalMessage"
                   ModalDangerText="@modalDangerText"
                   ModalButtonText="@modalButtonText"
                   OnConfirm="() => DeleteLine(lineToDelete)"
                   OnCancel="CloseDeleteDialog" />
}

@code {
    [Parameter] public int SectionId { get; set; }
    [Parameter] public List<SegmentCreateDto>? Segments { get; set; } = new();
    [Parameter] public EventCallback<List<SegmentCreateDto>> OnSegmentsUpdate { get; set; }
    [Parameter] public TabsComponent.TabsComponentItem? ActiveTab { get; set; } 
    // private List<SegmentCreateDto> segments = new();
    private List<ChordSimpleDto> chords = new();
    private int? focusedRow = null;
    private List<int> trackLines = new();
    private List<int> lines = new();
    private string? editModeSegmentId = null;
    private bool isOver = false;
    private string? modalTitle { get; set; }
    private string? modalSubtitle { get; set; }
    private string? modalMessage { get; set; }
    private string? modalDangerText { get; set; }
    private string? modalButtonText { get; set; }
    private bool showDeleteDialog = false;
    private int lineToDelete;

    protected override void OnInitialized()
    {
        try
        {
            trackLines = Segments
            .Where(s => s.PartName == SongSection.Verse && s.PartNumber == SectionId)
            .Select(s => s.LineNumber)
            .Distinct()
            .ToList();

            UpdateLines();
            if (lines.Count > 0) focusedRow = lines[0];
            StateHasChanged();
        }
        catch (Exception ex)
        {
            _logger.LogError("Error initializing SongSectionBoard: {Error}",ex);
        }

    }

    // protected override void OnParametersSet()
    // {
    //     if (InitialSegments != null)
    //     {
    //         Segments = InitialSegments;
    //         UpdateLines();
    //     }
    // }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JsRt.InvokeVoidAsync("initDragAndDrop");
        }
    }

    private void UpdateLines()
    {
        var segmentLines = Segments?
                        .Select(s => s.LineNumber)
                        .Distinct()
                        .ToList();
        if (segmentLines != null)
        {
            lines = segmentLines
                    .Union(trackLines)
                    .Distinct()
                    .OrderBy(l => l)
                    .ToList();
        }
    }

    private void HandleSegmentsUpdate(List<SegmentCreateDto> updatedSegments)
    {
        Segments = updatedSegments;
        UpdateLines();
        OnSegmentsUpdate.InvokeAsync(Segments.Select(s =>
        {
            s.PartNumber = SectionId;
            return s;
        }).ToList());
    }

    private void HandleChordsUpdate(List<ChordSimpleDto> updatedChords)
    {
        chords = updatedChords;
    }

    private void HandleEditModeSegmentIdChanged(string id)
    {
        editModeSegmentId = id;
    }

    private void SetFocusedRow(int line)
    {
        focusedRow = line;
    }

    private void AddLine(int afterLine)
    {
        try
        {
            var lineIndex = lines.IndexOf(afterLine);
            int tempLineId = -1 * (trackLines.Count + 1); 
            var newSegmentId = Guid.NewGuid().ToString();

            Segments?.Add(new SegmentCreateDto
            {
                Id = newSegmentId,
                Lyric = "",
                LineNumber = tempLineId,
                PartNumber = ActiveTab != null ? ActiveTab.SectionNumber : 1,
                PartName = ActiveTab != null ? ActiveTab.SectionEnumValue : SongSection.Verse,
                LyricOrder = 1 //first item in the new line
            });
            if (lineIndex >= 0 && lineIndex < trackLines.Count - 1)
            {
                trackLines.Insert(lineIndex + 1, tempLineId);
            }
            else
            {
                trackLines.Add(tempLineId);
            }

            RenumberLines();
            editModeSegmentId = newSegmentId;
            focusedRow = lines[lineIndex + 1];
            StateHasChanged();
        }
        catch (Exception ex)
        {
            _logger.LogError("Error adding line: {Error}", ex);
        }

    }

    private void RenumberLines()
    {
        try
        {
            var newLineMap = new Dictionary<long, int>();
            for (int i = 0; i < trackLines.Count; i++)
            {
                newLineMap[trackLines[i]] = i + 1;
            }

            Segments = Segments?.Select(s =>
            {
                if (newLineMap.ContainsKey(s.LineNumber))
                    s.LineNumber = newLineMap[s.LineNumber];
                return s;
            }).ToList();

            trackLines = trackLines.Select(l => newLineMap.ContainsKey(l) ? newLineMap[l] : l).ToList();
            UpdateLines();
            
        }
        catch (Exception ex)
        {
            _logger.LogError("Error renumbering lines: {Error}", ex);
        }    
    }

    private void ShowDeleteDialog(int line)
    {
        modalTitle = "Delete Line";
        modalSubtitle = "Are you sure you want to delete this line?";
        modalMessage = $"Segments in this line {line.ToString("00")}: will be deleted.";
        modalDangerText = "This action is irreversible!";
        modalButtonText = "Delete";
        lineToDelete = line;
        showDeleteDialog = true;
    }

    private void CloseDeleteDialog()
    {
        showDeleteDialog = false;
    }

    private void DeleteLine(int line)
    {
        Segments?.RemoveAll(s => s.LineNumber == line);
        trackLines.Remove(line);
        RenumberLines();

        if (trackLines.Count > 0)
        {
            focusedRow = trackLines[0];
        }
        else
        {
            focusedRow = null;
        }

        editModeSegmentId = null;
        showDeleteDialog = false;
        lineToDelete = 0;
    }

    private void HandleDragOver()
    {
        isOver = true;
    }

    private void HandleDragLeave()
    {
        isOver = false;
    }

    private async Task HandleDrop(DragEventArgs e, int line)
    {
        isOver = false;
        var segmentId = await JsRt.InvokeAsync<string>("getDragData", "segmentId");
        Segments?.RemoveAll(s => s.Id == segmentId);
    }
}