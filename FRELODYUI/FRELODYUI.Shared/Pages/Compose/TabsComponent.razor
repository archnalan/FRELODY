@inject ILogger<TabsComponent> _logger

<div class="d-flex justify-content-center align-items-center py-4">
    <div class="d-flex flex-column w-100">
        <div class="p-2 border border-secondary rounded rounded-3">
            
            <SortableList @key="_sortableListKey" 
                          Id="sortable-tabs"
                          Handle=".drag-handle"
                          Items="Items"
                          OnUpdate="@SortTabs"
                          Context="item"
                          Class="p-2 border rounded rounded-3 flex-wrap d-flex  gap-2 fw-bold text-primary">
               <SortableItemTemplate>
                    <div @key="@($"tab-{item.Id}-{item.DisplayOrder}")" class="d-flex align-items-center gap-2" style="transition: transform 0.2s ease-in-out;">
                            <div class="drag-handle d-flex align-items-center justify-content-center text-muted"
                                 style="cursor: grab; width: 20px; height: 100%; min-height: 40px;"
                                 title="Drag to reorder">
                                <i class="bi bi-grip-vertical"></i>
                            </div>
                            <div class="@GetTabClass(item.Id)" @onclick="() => SetSelectedTab(item)">
                            <div class="d-inline-flex align-items-center">
                                <select class="form-select form-select-sm border-secondary fw-normal p-1"
                                        style="min-width:5.5rem"
                                        value="@item.SectionName"
                                        @onmousedown:preventDefault="SelectedTab != item.Id"
                                        @onchange="@((ChangeEventArgs e) => HandleSectionChanged(item.Id, e.Value?.ToString()))">
                                    @foreach (var sectionName in SongSectionNames)
                                    {
                                        <option value="@sectionName"
                                                disabled="@(IsSectionDisabled(sectionName, item.Id))"
                                                class="@(sectionName == nameof(SongSection.unknown) ? "d-none" : "")">
                                            @((sectionName.Length > NAME_MAX_LEN ? sectionName.Substring(0, NAME_MAX_LEN) + "..." : sectionName))
                                        </option>
                                    }
                                </select>
                                @if (SectionAllowsNumbering(item.SectionName))
                                {
                                    <div class="position-relative">
                                        <input @ref="_sectionNumberInputs[item.Id]"
                                               id="section-number-@item.Id"
                                               class="form-control form-control-sm ms-1"
                                               type="number"
                                               style="width:3rem;"
                                               min="0"
                                               value="@(item.SectionNumber == 0 ? "" : item.SectionNumber.ToString())"
                                               @onchange="@(e => HandleSectionNumberChanged(item.Id, e))"
                                               @onmousedown:preventDefault="SelectedTab != item.Id" />
                                        @if (ShowInputHide)
                                        {
                                            <span class="d-flex align-items-center justify-content-center position-absolute top-0 start-50 translate-middle badge rounded-circle bg-danger text-center"
                                                  style="width:1.25rem; height:1.25rem" @onclick="() => HideNumberInputFromSection(item)"
                                                  @onmousedown:preventDefault="SelectedTab != item.Id">
                                                <i class="bi bi-x"></i>
                                            </span>
                                        }
                                    </div>
                                }
                            </div>
                            <div class="d-flex align-items-center">
                                <button class="btn btn-sm btn-outline-light rounded-circle text-primary text-decoration-none m-1"
                                        @onclick="() => HandleTabRemove(item)"
                                        @onclick:stopPropagation="true"
                                        title="Remove section">
                                    <i class="bi bi-x text-danger"></i>
                                </button>
                            </div>
                        </div>
                        </div>
                    </SortableItemTemplate>
               <ActionItemTemplate>
                        <div class="d-flex align-items-center">
                            <button class="btn btn-sm btn-link text-primary text-decoration-none rounded-circle"
                                    style="width:2.5rem; height:2.5rem"
                                    @onclick="HandleAddTab"
                                    disabled="@(Items.Count >= ItemsCountLimit)">
                                <i class="bi bi-plus-lg"></i>
                            </button>
                        </div>
                    </ActionItemTemplate>
            </SortableList>            
        </div>

        <div class="p-3 border border-secondary rounded mt-4">
            @foreach (var item in Items)
            {
                <div @key="@($"content-{item.Id}-{item.DisplayOrder}")" class="@(SelectedTab == item.Id ? "" : "d-none")">
                    @item.Content
                </div>
            }
        </div>
    </div>
</div>

@if (_modalService.IsModalVisible)
{
    <DialogModal IsVisible="true"
                 Modal="@_modalService.CurrentModal"
                 OnCloseModal="CloseModal"
                 OnConfirmModal="ConfirmModal" />
}

@code {
    [Parameter] public List<TabItem>? InitialItems { get; set; }
    [Parameter] public int ItemsCountLimit { get; set; }
    [Parameter] public EventCallback<int> OnTabAdd { get; set; }
    [Parameter] public Func<int, RenderFragment>? RenderTab { get; set; }
    [Parameter] public EventCallback<TabItem> ActiveTabInfoChanged { get; set; }
    [Parameter] public EventCallback<List<TabItem>> OnTabSort { get; set; }
    [Parameter] public EventCallback<int> OnTabRemoved { get; set; }
    private readonly Dictionary<int, ElementReference> _sectionNumberInputs = new();

    public List<TabItem> Items { get; set; } = new();
    private string[] SongSectionNames { get; set; } = [];
    private int SelectedTab { get; set; } = 1;
    private int? tabIdToRemove = null;
    private const int INITIAL_ID = 1;
    private const int NAME_MAX_LEN = 7;
    private int _sortableListKey = 0;

    private bool ShowInputHide = false;
    private readonly HashSet<string> SingleInstanceSections = new()
    {
        nameof(SongSection.Intro),
        nameof(SongSection.Outro),
        nameof(SongSection.Coda)
    };
    private bool SectionAllowsNumbering(string sectionName) => !SingleInstanceSections.Contains(sectionName);

    public void SetSelectedTab(TabItem active)
    {
        if (SelectedTab != active.Id)
        {
            SelectedTab = active.Id;
            if (ActiveTabInfoChanged.HasDelegate)
            {
                ActiveTabInfoChanged.InvokeAsync(active);
            }
        }
        _tabsManager.ActiveTab = active;
    }

    private string GetTabClass(int id) =>
        SelectedTab == id
            ? "d-inline-flex py-2 ps-2 pe-1 align-items-center rounded rounded-3 border border-primary bg-light text-primary shadow cursor-pointer fw-bold"
            : "d-inline-flex py-2 ps-2 pe-1 align-items-center cursor-pointer hover-light fw-bold text-primary";

    private List<TabItem> GetOrderedItems() =>
        Items.OrderBy(item => Array.IndexOf(SongSectionNames, item.SectionName))
             .ThenBy(item => item.SectionNumber)
             .ToList();

    protected override async Task OnInitializedAsync()
    {
        // Extract enum values once during initialization
        SongSectionNames = Enum.GetNames(typeof(SongSection));

        if (InitialItems != null)
        {
            // Preserve parent-provided Ids; only compute DisplayOrder locally.
            Items = InitialItems.Select((item, i) => new TabItem
            {
                Id = item.Id,
                SectionName = item.SectionName,
                SectionNumber = item.SectionNumber,
                Content = item.Content,
                DisplayOrder = i + 1
            }).ToList();
        }
        Items = Items.OrderBy(x => x.DisplayOrder).ToList();
        _tabsManager.TabItems = Items;
        _tabsManager.ActiveTab = Items.FirstOrDefault(i => i.Id == SelectedTab);
        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var module = await JsRt.InvokeAsync<IJSObjectReference>("import", "./_content/FRELODYUI.Shared/Pages/Compose/TabsComponent.razor.js");
            //await module.InvokeAsync<string>("init", Id, Group, Pull, Put, Sort, Handle, Filter, selfReference);
        }
    }

    private void SortTabs((int oldIndex, int newIndex) indices)
    {
        var (oldIndex, newIndex) = indices;

        if (oldIndex == newIndex) return;

        // Remember the currently selected tab before reordering
        var currentlySelectedTab = SelectedTab;

        var itemToMove = Items[oldIndex];
        Items.RemoveAt(oldIndex);

        if (newIndex < Items.Count)
        {
            Items.Insert(newIndex, itemToMove);
        }
        else
        {
            Items.Add(itemToMove);
        }

        // Update display order to match new positions
        for (int i = 0; i < Items.Count; i++)
        {
            Items[i].DisplayOrder = i + 1;
        }

        // Renumber SectionNumber within each section type group
        var groupedItems = Items
            .Where(item => SectionAllowsNumbering(item.SectionName))
            .GroupBy(item => item.SectionName)
            .ToList();

        foreach (var group in groupedItems)
        {
            var sortedGroup = group.OrderBy(item => item.DisplayOrder).ToList();
            for (int i = 0; i < sortedGroup.Count; i++)
            {
                sortedGroup[i].SectionNumber = i + 1;
            }
        }

        // Maintain the previously selected tab instead of automatically selecting the moved tab
        // Only change selection if the currently selected tab doesn't exist anymore
        if (Items.Any(item => item.Id == currentlySelectedTab))
        {
            SelectedTab = currentlySelectedTab;
            var activeTab = Items.FirstOrDefault(item => item.Id == currentlySelectedTab);
            if (activeTab != null && ActiveTabInfoChanged.HasDelegate)
            {
                ActiveTabInfoChanged.InvokeAsync(activeTab);
            }
        }
        else if (Items.Any())
        {
            // Fallback: select the first tab if the previously selected tab no longer exists
            SelectedTab = Items[0].Id;
            if (ActiveTabInfoChanged.HasDelegate)
            {
                ActiveTabInfoChanged.InvokeAsync(Items[0]);
            }
        }
        Items = Items.OrderBy(x => x.DisplayOrder).ToList();
        // Notify parent first so it can realign segment data before we refresh UI
        if (OnTabSort.HasDelegate)
        {
            OnTabSort.InvokeAsync(Items);
        }

        // Force UI refresh
        _sortableListKey++;
        _tabsManager.TabItems = Items;
        _tabsManager.ActiveTab = Items.FirstOrDefault(i => i.Id == SelectedTab);
        StateHasChanged();
    }

    private bool IsSectionCombinationTaken(string sectionName, int sectionNumber, int excludeId = 0)
    {
        // For single-instance sections, only check if the section name is taken
        if (!SectionAllowsNumbering(sectionName))
        {
            return Items.Any(item => item.SectionName == sectionName && item.Id != excludeId);
        }

        return Items.Any(item => item.SectionName == sectionName &&
                         item.SectionNumber == sectionNumber &&
                         item.Id != excludeId);
    }

    private bool IsSectionDisabled(string sectionName, int currentTabId)
    {
        // If it's not a single instance section, it's never disabled
        if (!SingleInstanceSections.Contains(sectionName))
        {
            return false;
        }

        // Check if this single instance section is already used by another tab
        return Items.Any(item => item.SectionName == sectionName && item.Id != currentTabId);
    }

    private int GetOptimalSectionNumber(string sectionName, int preferredNumber, int excludeId = 0)
    {
        if (!SectionAllowsNumbering(sectionName))
        {
            return 1;
        }

        // If the preferred number is available, use it
        if (!IsSectionCombinationTaken(sectionName, preferredNumber, excludeId))
        {
            return preferredNumber;
        }

        // Find all taken numbers for this section (excluding current item)
        var takenNumbers = Items.Where(item => item.SectionName == sectionName && item.Id != excludeId)
                               .Select(item => item.SectionNumber)
                               .OrderBy(n => n)
                               .ToList();

        // Try to find a gap in the sequence starting from 1
        for (int i = 1; i <= takenNumbers.Count + 1; i++)
        {
            if (!takenNumbers.Contains(i))
            {
                return i;
            }
        }

        // Fallback (should never reach here with the logic above)
        return takenNumbers.Count + 1;
    }

    private void SwapTabPositions(TabItem sourceTab, TabItem targetTab)
    {
        // Swap only the display order to maintain user's visual arrangement
        (sourceTab.DisplayOrder, targetTab.DisplayOrder) = (targetTab.DisplayOrder, sourceTab.DisplayOrder);

        // Re-sort the Items list by display order to maintain the visual sequence
        Items = Items.OrderBy(item => item.DisplayOrder).ToList();
    }

    private async Task ReorderAndInsertTab(TabItem tab, int newSectionNumber)
    {
        var oldNumber = tab.SectionNumber;
        var sameSection = Items
            .Where(item => item.SectionName == tab.SectionName && item.Id != tab.Id)
            .OrderBy(item => item.SectionNumber)
            .ToList();

        var conflictingItem = sameSection.FirstOrDefault(item => item.SectionNumber == newSectionNumber);
        if (conflictingItem != null)
        {
            // Instead of shifting all items, just swap positions with the conflicting item
            SwapTabPositions(tab, conflictingItem);

            // Update section numbers
            tab.SectionNumber = newSectionNumber;
            conflictingItem.SectionNumber = oldNumber;

            // Notify parent of both changed tabs
            if (ActiveTabInfoChanged.HasDelegate)
            {
                await ActiveTabInfoChanged.InvokeAsync(tab);
                await ActiveTabInfoChanged.InvokeAsync(conflictingItem);
            }

            await FocusElementAsync(tab.Id);
        }
        else
        {
            // No conflict, just update the number
            tab.SectionNumber = newSectionNumber;

            if (ActiveTabInfoChanged.HasDelegate)
            {
                await ActiveTabInfoChanged.InvokeAsync(tab);
            }
        }
        await Task.CompletedTask;
        StateHasChanged();
    }

    private async Task HandleSectionChanged(int tabId, string? newSectionName)
    {
        var tab = Items.FirstOrDefault(item => item.Id == tabId);

        if (tab == null || string.IsNullOrEmpty(newSectionName)) return;

        var oldSectionName = tab.SectionName;
        tab.SectionName = newSectionName;

        // If the section name changed, find the optimal number for the new section
        if (oldSectionName != newSectionName)
        {
            var optimalNumber = GetOptimalSectionNumber(newSectionName, tab.SectionNumber, tabId);

            // Check if there's a conflict with the optimal number
            if (IsSectionCombinationTaken(newSectionName, optimalNumber, tabId))
            {
                // Find the item that conflicts and swap positions
                var conflictingItem = Items.FirstOrDefault(item => 
                    item.SectionName == newSectionName && 
                    item.SectionNumber == optimalNumber && 
                    item.Id != tabId);

                if (conflictingItem != null)
                {
                    // Swap display positions and section numbers
                    SwapTabPositions(tab, conflictingItem);
                    var tempNumber = tab.SectionNumber;
                    tab.SectionNumber = optimalNumber;
                    conflictingItem.SectionNumber = tempNumber;
                    conflictingItem.SectionName = oldSectionName;

                    // Notify parent of both changes
                    if (ActiveTabInfoChanged.HasDelegate)
                    {
                        await ActiveTabInfoChanged.InvokeAsync(conflictingItem);
                    }
                }
            }
            else
            {
                tab.SectionNumber = optimalNumber;
            }
        }

        // Ensure the edited tab remains selected
        SelectedTab = tabId;
        _tabsManager.ActiveTab = tab;
        if (ActiveTabInfoChanged.HasDelegate)
        {
            await ActiveTabInfoChanged.InvokeAsync(tab);
        }

        StateHasChanged();
    }

    private async Task HandleSectionNumberChanged(int tabId, ChangeEventArgs e)
    {
        var tab = Items.FirstOrDefault(item => item.Id == tabId);
        if (tab == null) return;

        if (string.IsNullOrWhiteSpace(e.Value?.ToString()) || !int.TryParse(e.Value?.ToString(), out int newNumber) || newNumber <= 0)
        {
            // Check if section name appears only once in Items list, show the hide input button
            if (Items.Count(i => i.SectionName == tab.SectionName) == 1)
            {
                if(tab.SectionName != nameof(SongSection.Verse)) //default verse section should be numbered
                    ShowInputHide = true;
            }
            else
            {
                ShowInputHide = false;
            }

            tab.SectionNumber = 1; //minimum valid section number
            SelectedTab = tabId;
            _tabsManager.ActiveTab = tab;
            if (ActiveTabInfoChanged.HasDelegate)
            {
                await ActiveTabInfoChanged.InvokeAsync(tab);
            }
            StateHasChanged();
            return;
        }

        // Handle valid positive numbers
        ShowInputHide = false;

        // Check if this is just staying at the same number (no change needed)
        if (tab.SectionNumber == newNumber)
        {
            return;
        }

        // If the target number is available, just set it
        if (!IsSectionCombinationTaken(tab.SectionName, newNumber, tabId))
        {
            tab.SectionNumber = newNumber;
        }
        else
        {
            // There's a conflict - use swap logic instead of shifting all items
            await ReorderAndInsertTab(tab, newNumber);
        }

        // Ensure the edited tab remains selected
        SelectedTab = tabId;
        _tabsManager.ActiveTab = tab;
        if (ActiveTabInfoChanged.HasDelegate)
        {
            await ActiveTabInfoChanged.InvokeAsync(tab);
        }

        StateHasChanged();
    }

    private void HandleTabRemove(TabItem tab)
    {
        if(SelectedTab != tab.Id)
        {
            SetSelectedTab(tab);
            StateHasChanged();
            return;// activate tab first
        }
        tabIdToRemove = tab.Id;
        _modalService.Show(new ModalOptionDto
        {
            Title = "Remove Section",
            Message = "Are you sure you want to remove this section? All section data will be lost!",
            ButtonText = "Remove",
            OptionType = OptionType.Confirmation,
            Context = new ModalContext
            {
               ActionType = "RemoveTab",
                Data = tab.Id
            }
        });       
    }

    public void HandleAddTab()
    {
        if (Items.Count >= ItemsCountLimit) return;

        var newId = Items.Any() ? Items.Max(i => i.Id) + 1 : INITIAL_ID;
        var defaultSectionName = nameof(SongSection.Verse);

        // Get next available number at the end
        var maxNumber = Items
            .Where(item => item.SectionName == defaultSectionName)
            .Select(item => item.SectionNumber)
            .DefaultIfEmpty(0)
            .Max();

        var sectionNumber = maxNumber + 1;

        // Get the next display order to maintain sequence
        var maxDisplayOrder = Items.Any() ? Items.Max(i => i.DisplayOrder) : 0;

        var newTab = new TabItem
        {
            Id = newId,
            SectionName = defaultSectionName,
            SectionNumber = sectionNumber,
            Content = RenderTab!.Invoke(newId),
            DisplayOrder = maxDisplayOrder + 1
        };

        Items.Add(newTab);
        SelectedTab = newId;
        _tabsManager.TabItems = Items;
        _tabsManager.ActiveTab = newTab;
        OnTabAdd.InvokeAsync(newId);
    }

    private void CloseModal()
    {
        _modalService.Close();
        if(_modalService.CurrentModal.Context?.ActionType == "RemoveTab")
        {
            tabIdToRemove = null;
        }
        else
        {
            _modalService.CurrentModal.Context = null; 
        }
        tabIdToRemove = null;
        StateHasChanged();
    }

    private async Task ConfirmModal()
    {
        var context = _modalService.CurrentModal.Context;

        if (context?.ActionType == "RemoveTab")
        {
            if (tabIdToRemove.HasValue)
            {
                Items.RemoveAll(item => item.Id == tabIdToRemove.Value);
                _sectionNumberInputs.Remove(tabIdToRemove.Value);
                _tabsManager.TabItems = Items;
                if (SelectedTab == tabIdToRemove.Value && Items.Count > 0)
                {
                    SelectedTab = Items[0].Id;
                    _tabsManager.ActiveTab = Items[0];
                }
                OnTabRemoved.InvokeAsync(tabIdToRemove.Value);
            }
            tabIdToRemove = null;
            StateHasChanged();
        }
        else if (context?.ActionType == "HideSectionNumber")
        {
            if (context.Data is int itemId)
            {
                var tab = Items.FirstOrDefault(item => item.Id == itemId);
                if (tab != null)
                {
                    // Add the section to SingleInstanceSections
                    SingleInstanceSections.Add(tab.SectionName);

                    // Reset section number to 1 and hide the input
                    tab.SectionNumber = 1;
                    ShowInputHide = false;

                    // Notify parent of the change
                    if (ActiveTabInfoChanged.HasDelegate)
                    {
                        await ActiveTabInfoChanged.InvokeAsync(tab);
                    }

                    StateHasChanged();
                }
            }
        }

        _modalService.Close();
    }

    private async Task FocusElementAsync(int tabId)
    {
        if (_sectionNumberInputs.TryGetValue(tabId, out var elementRef))
        {
            try
            {
                await elementRef.FocusAsync();
            }
            catch (Exception)
            {
                // Fallback to JS interop if Blazor reference fails
                await JsRt.InvokeVoidAsync("eval", $"document.getElementById('section-number-{tabId}')?.focus()");
            }
        }
    }

    private async Task HideNumberInputFromSection(TabItem item)
    {
        _modalService.Show(new ModalOptionDto
        {
            Title = "Hide Section Number",
            Message = $"Are you sure you want to hide the section number for {item.SectionName}? This action is irreversible! You will create only one {item.SectionName}!",
            ButtonText = "Hide",
            OptionType = OptionType.Confirmation,
            Context = new ModalContext
            {
                ActionType = "HideSectionNumber",
                Data = item.Id
            }
        });
        await Task.CompletedTask;
    }

    private void SyncTabManager()
    {
        _tabsManager.TabItems = Items;
        _tabsManager.ActiveTab = Items.FirstOrDefault(i => i.Id == SelectedTab);
    }

}

