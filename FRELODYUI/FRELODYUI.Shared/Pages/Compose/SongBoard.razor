@page "/compose"
@using Microsoft.AspNetCore.WebUtilities
@attribute [Authorize(Roles = $"{nameof(UserRoles.Editor)},{nameof(UserRoles.Contributor)}")]
@implements IDisposable
@inject ILogger<SongBoard> _logger

<div class="w-100 d-flex flex-column justify-content-center"
     style="max-width: 65rem;justify-self: center;">
	<h3 class="fw-bold text-center mb-3">Song Editor</h3>
    @if (isLoading)
    {
        <div class="d-flex justify-content-center my-5">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
    }
    else
    {
        <div class="row row-cols-lg-12 g-2 align-items-center">
            <!-- Input 1 -->
            <div class="col-3 col-md-2">
                <input type="number"
                       @bind="FormattedSongNumber"
                       class="form-control"
                       placeholder="Song #"
                       min="1" />
            </div>

            <!-- Input 2 -->
            <div class="col-9 col-md-4">
                <input type="text"
                       @bind="SongTitle"
                       class="form-control"
                       placeholder="Song Title" />
            </div>

            <!-- Selection Tabs and Dropdowns -->
            <div class="col-9 col-md-4">
                <!-- Tab Navigation -->
                <ul class="nav nav-tabs nav-fill mb-2" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link @(activeSelectionTab == "songbook" ? "active" : "")"
                                type="button"
                                @onclick='() => SetActiveSelectionTab("songbook")'>
                            <i class="bi bi-book"></i> Songbook
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link @(activeSelectionTab == "artist" ? "active" : "")"
                                type="button"
                                @onclick='() => SetActiveSelectionTab("artist")'>
                            <i class="bi bi-person"></i> Artist/Album
                        </button>
                    </li>
                </ul>

                <!-- Tab Content -->
                <div class="tab-content">
                    <!-- Songbook Flow -->
                    @if (activeSelectionTab == "songbook")
                    {
                        @if (string.IsNullOrEmpty(selectedSongBook?.Id))
                        {
                            <SongBookDropdown @ref="songBookDropdownRef"
                                              SelectedSongBook="selectedSongBook"
                                              SelectedSongBookChanged="HandleSongBookChanged" />
                        }
                        else if (selectedSongBook != null && !string.IsNullOrEmpty(selectedSongBook.Id))
                        {
                            <div class="w-100 row">
                                <div class="col-4 btn btn-link text-decoration-none"
                                     @onclick="ChangeBookSelection">
                                    <strong class="text-sm-start">
                                        @(selectedSongBook.Title.Length > MAX_TITLE_LEN
                                                                    ? selectedSongBook.Title.Substring(0, 15) + "…"
                                                                    : selectedSongBook.Title)
                        </strong>
                    </div>
                    <div class="col-8">
                        <CategoriesDropdown SelectedCategory="@selectedCategory"
                                            SelectedCategoryChanged="HandleCategoryChanged"
                                            SongBookId="@selectedSongBook.Id"
                                            TabIndex="10" />
                    </div>
                </div>
                                }
                    }

                    <!-- Artist/Album Flow -->
                    @if (activeSelectionTab == "artist")
                    {
                        @if (string.IsNullOrEmpty(selectedArtist?.Id))
                        {
                            <ArtistDropdown @ref="artistDropdownRef"
                                            SelectedArtist="selectedArtist"
                                            SelectedArtistChanged="HandleArtistChanged" />
                        }
                        else if (selectedArtist != null && !string.IsNullOrEmpty(selectedArtist.Id))
                        {
                            <div class="w-100 row">
                                <div class="col-4 btn btn-link text-decoration-none"
                                     @onclick="ChangeArtistSelection">
                                    <strong class="text-sm-start">
                                        @(selectedArtist.Name.Length > MAX_TITLE_LEN
                                                                    ? selectedArtist.Name.Substring(0, 15) + "…"
                                                                    : selectedArtist.Name)
                        </strong>
                    </div>
                    <div class="col-8">
                        <AlbumDropdown SelectedAlbum="@selectedAlbum"
                                       SelectedAlbumChanged="HandleAlbumChanged"
                                       ArtistId="@selectedArtist.Id"
                                       TabIndex="10" />
                    </div>
                </div>
                                }
                    }
                </div>
            </div>

            <!-- Save Button -->
            <div class="col-3 col-md-2 d-grid">
                <button type="button" 
                        class="btn btn-outline-primary"
                        @onclick="HandleSongSave" >
                    <span class="me-2 d-none d-md-inline">Save Song</span>
                    <i class="bi bi-clipboard-check"></i>
                </button>
            </div>
        </div>

        @if (initialPartsItems.Any())
        {
            <TabsComponent @ref="TabsComponentRef"
                           InitialItems="initialPartsItems"
                           ItemsCountLimit="MAX_SECTIONS"
                           OnTabAdd="HandleTabAdd"
                           RenderTab="RenderVerseTab"
                           OnTabSort="HandleTabSort"
                           OnTabRemoved="HandleTabRemove"
                           ActiveTabInfoChanged ="HandleActiveTabInfoChanged"/>
        }
        else
        {
            <div class="alert alert-warning mt-2">
                No sections found. Click to <span class="btn-link" style="cursor:pointer" @onclick="InitializeNewContent">add a new section</span>
            </div>
        }
    }
    
</div>
<DialogModal IsVisible="@_modalService.IsModalVisible"
             Modal="@_modalService.CurrentModal"
             OnCloseModal="CloseModal"
             OnConfirmModal="ConfirmModal" />

@code {
    [Parameter]
    public string? SongId { get; set; }
    const int MAX_SECTIONS = 25;
    private string SongTitle = "My New Song";
    private int SongNumber = 1;   
    private Dictionary<int, List<SegmentCreateDto>> AllPartsSegments =
    new() { [1] = new List<SegmentCreateDto>() };
    private List<TabItem> initialPartsItems = new();
    private TabItem? activeTabItem;

    private SongBookDto? selectedSongBook = null;
    private CategoryDto? selectedCategory = null;

    private ArtistDto? selectedArtist = null;
    private AlbumDto? selectedAlbum = null;

    private SimpleSongCreateDto songData = new();
    private SongBookDropdown? songBookDropdownRef;
    private ArtistDropdown? artistDropdownRef;
    private TabsComponent? TabsComponentRef;
    private const int MAX_TITLE_LEN = 15;
    private bool isLoading = true;
    private string activeSelectionTab = "songbook";

    private RenderFragment RenderVerseTab(int id) => @<SongSectionBoard SectionId="@id"
                  Segments="@AllPartsSegments.GetValueOrDefault(id, new List<SegmentCreateDto>())"
                  ActiveTab="activeTabItem" 
                  OnSegmentsUpdate="segments => HandleVerseUpdate(id, segments)" />
    ;
    private string FormattedSongNumber
    {
        get => SongNumber.ToString("D3");
        set
        {
            if (int.TryParse(value, out var num))
            {
                SongNumber = num;
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var uri = _navManager.ToAbsoluteUri(_navManager.Uri);
            var query = QueryHelpers.ParseQuery(uri.Query);
            if (query.TryGetValue("songId", out var songIdValues))
            {
                SongId = songIdValues.FirstOrDefault();
            }
            if (string.IsNullOrEmpty(SongId))
            {
                InitializeNewContent();
            }
            else
            {
                var response = await _songsApi.GetSongWithChordsById(SongId);
                if (response.IsSuccessStatusCode)
                {
                    var song = response.Content!;
                    SongTitle = song.Title;
                    SongNumber = song.SongNumber ?? 0;
                    initialPartsItems = new List<TabItem>();
                    AllPartsSegments = new Dictionary<int, List<SegmentCreateDto>>();
                    if (!string.IsNullOrEmpty(song.AlbumId)) GetAlbum(song.AlbumId);
                    else if (!string.IsNullOrEmpty(song.CategoryId)) GetBookCategory(song.CategoryId);

                    // Process parts
                    foreach (var part in song.SongParts!.OrderBy(v => v.PartNumber))
                    {
                        var verseSegments = new List<SegmentCreateDto>();
                        foreach (var line in part.LyricLines!.OrderBy(ll => ll.LyricLineOrder))
                        {
                            foreach (var segment in line.LyricSegments!.OrderBy(ls => ls.LyricOrder))
                            {
                                verseSegments.Add(new SegmentCreateDto
                                    {
                                        Id = segment.Id.ToString(),
                                        Lyric = segment.Lyric,
                                        ChordId = segment.ChordId?.ToString(),
                                        ChordName = segment.Chord?.ChordName,
                                        ChordAlignment = segment.ChordAlignment,
                                        LineNumber = line.LyricLineOrder,
                                        PartNumber = part.PartNumber,
                                        PartName = part.PartName ?? SongSection.Verse,
                                        LyricOrder = segment.LyricOrder
                                    });
                            }
                        }

                        AllPartsSegments[part.PartNumber] = verseSegments;

                        initialPartsItems.Add(new TabItem
                            {
                                Id = part.PartNumber,
                                SectionName = part.PartName.ToString() ?? nameof(SongSection.Verse),
                                SectionNumber = part.PartNumber,
                                Content = builder =>
                                {
                                    builder.OpenComponent<SongSectionBoard>(0);
                                    builder.AddAttribute(1, "SectionId", part.PartNumber);
                                    builder.AddAttribute(2, "OnSegmentsUpdate",
                                        EventCallback.Factory.Create<List<SegmentCreateDto>>(
                                            this, segments => HandleVerseUpdate(part.PartNumber, segments)));
                                    builder.AddAttribute(3, "Segments", AllPartsSegments[part.PartNumber]);
                                    builder.AddAttribute(4, "ActiveTab", activeTabItem);
                                    builder.CloseComponent();
                                }
                            });
                    }
                }
                else
                {
                    var errorMessage = _apiResponseHandler.GetApiErrorMessage(response);
                    _modalService.Show(new ModalOptionDto
                    {
                        Title = "Error",
                        Message = errorMessage,
                        ButtonText = "Close",
                        OptionType = OptionType.Error,
                        Context = new ModalContext
                        {
                            ActionType = "SongLoadError",
                            Data = response.Content?.ToString() ?? "No content"
                        }
                    });
                }
            }
            _tabsManager.OnRelocateLine += HandleRelocateLineRequest;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error initializing song board");
            _modalService.Show(new ModalOptionDto
            {
                Title = "Initialization Error",
                Message = "An error occurred while initializing the song board. Please try again later.",
                ButtonText = "Close",
                OptionType = OptionType.Error,
                Context = new ModalContext
                {
                    ActionType = "InitializationError",
                    Data = ex.Message
                }
            });            
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }

    }

    private async void GetAlbum(string albumId)
    {
        var albumResponse = await _albumsApi.GetAlbumById(albumId);
        if (albumResponse.IsSuccessStatusCode)
        {
            var album = albumResponse.Content!;
            selectedAlbum = album;
            var artistResponse = await _artistsApi.GetArtistById(album.ArtistId ?? "");
            if (artistResponse.IsSuccessStatusCode)
            {
                selectedArtist = artistResponse.Content!;
            }
        }
        if (selectedAlbum !=null || selectedArtist != null)
        {
            SetActiveSelectionTab("artist");
        }
        StateHasChanged();  
    }

    private async void GetBookCategory(string categoryId)
    {
        var categoryResponse = await _categoriesApi.GetCategoryById(categoryId);
        if (categoryResponse.IsSuccessStatusCode)
        {
            selectedCategory = categoryResponse.Content!;
            if (!string.IsNullOrEmpty(selectedCategory.SongBookId))
            {
                var bookResponse = await _songsBooksApi.GetSongBookById(selectedCategory.SongBookId);
                if (bookResponse.IsSuccessStatusCode)
                {
                    selectedSongBook = bookResponse.Content!;
                }
            }
        }
        if (selectedCategory != null || selectedSongBook != null)
        {
            SetActiveSelectionTab("songbook");
        }
        StateHasChanged();
    }
    
    private void SetActiveSelectionTab(string tab)
    {
        activeSelectionTab = tab;

        // Clear the other tab's selections when switching
        if (tab == "songbook")
        {
            selectedArtist = null;
            selectedAlbum = null;
        }
        else if (tab == "artist")
        {
            selectedSongBook = null;
            selectedCategory = null;
            songData.SongBookId = null;
            songData.CategoryId = null;
        }

        StateHasChanged();
    }

    private void InitializeNewContent()
    {
        // Initialize new song
        initialPartsItems = new List<TabItem>
                {
                    new TabItem
                    {
                        Id = 1,
                        SectionName = nameof(SongSection.Verse),
                        SectionNumber = 1,
                        Content = builder =>
                        {
                            builder.OpenComponent<SongSectionBoard>(0);
                            builder.AddAttribute(1, "SectionId", 1);
                            builder.AddAttribute(2, "OnSegmentsUpdate",
                                EventCallback.Factory.Create<List<SegmentCreateDto>>(
                                    this, segments => HandleVerseUpdate(1, segments)));
                            builder.AddAttribute(3, "Segments", AllPartsSegments[1]);
                            builder.AddAttribute(4, "ActiveTab", activeTabItem);
                            builder.CloseComponent();
                        }
                    }
                };
        AllPartsSegments[1] = new List<SegmentCreateDto>();
    }

    private async Task HandleSongSave()
    {
        var allSegments = AllPartsSegments.Values.SelectMany(v => v).ToList();

        songData.Title = SongTitle;
        songData.SongNumber = SongNumber;
        songData.SongLyrics = allSegments;

        if (allSegments.Count == 0)
        {
            _modalService.Show(new ModalOptionDto
            {
                Title = "No Segments",
                Message = "Please add at least one segment to save the song.",
                ButtonText = "OK",
                OptionType = OptionType.Warning,
                Context = new ModalContext
                {
                    ActionType = "NoSegments",
                    Data = "Attempted to save song with no segments"
                }
            });

            _logger.LogWarning("No segments found to save.");
            return;
        }

        Refit.IApiResponse<SongDto> songResult;
        if (string.IsNullOrEmpty(SongId) || SongId == "new")
        {
            SongId = null;
            songResult = await _songsApi.CreateSong(songData);
        }
        else
        {
            songResult = await _songsApi.UpdateSong(SongId, songData);
        }

        if (songResult.IsSuccessStatusCode)
        {
            _modalService.Show(new ModalOptionDto
            {
                Title = "Song Saved",
                Message = $"Song '{SongTitle}' saved successfully!",
                ButtonText = "OK",
                OptionType = OptionType.Success,
                Context = new ModalContext
                {
                    ActionType = "SongSaved",
                    Data = songResult.Content?.ToString() ?? "No content"
                }
            });

            _logger.LogInformation("Song {songData} saved successfully!", songData);
        }
        else
        {
            var errorMessage = _apiResponseHandler.GetApiErrorMessage(songResult);
            _modalService.Show(new ModalOptionDto
            {
                Title = "Save Error",
                Message = errorMessage,
                ButtonText = "Close",
                OptionType = OptionType.Error,
                Context = new ModalContext
                {
                    ActionType = "SongSaveError",
                    Data = songResult.Content?.ToString() ?? "No content"
                }
            });

            _logger.LogError("Failed to save song: {Error}", errorMessage);
        }
    }

    private void HandleActiveTabInfoChanged(TabItem tabItem)
    {
        activeTabItem = tabItem;

        if (AllPartsSegments.TryGetValue(tabItem.Id, out var segments))
        {
            foreach (var segment in segments)
            {
                segment.PartNumber = tabItem.SectionNumber;
                segment.PartName = tabItem.SectionEnumValue;
            }
        }
        StateHasChanged();
    }

    private void HandleVerseUpdate(int sectionId, List<SegmentCreateDto> segments)
    {
        AllPartsSegments[sectionId] = segments; 
    }

    private void HandleTabAdd(int newTabId)
    {
        if (!AllPartsSegments.ContainsKey(newTabId))
        {
            AllPartsSegments[newTabId] = new List<SegmentCreateDto>();
            if(TabsComponentRef != null)
            {
                initialPartsItems = TabsComponentRef.Items; //syncing items data
                _tabsManager.TabItems = TabsComponentRef.Items; //syncing manager data
            }
        }
    }

    private void HandleTabSort(List<TabItem> sortedItems)
    {
        // Create new segments dictionary preserving the content but updating positions
        var newAllPartsSegments = new Dictionary<int, List<SegmentCreateDto>>();

        // Copy segments to their new positions and update part numbers
        for (int i = 0; i < sortedItems.Count; i++)
        {
            var tab = sortedItems[i];
            var newPartNumber = i + 1; // Position-based part number (1, 2, 3, etc.)

            if (AllPartsSegments.TryGetValue(tab.Id, out var segments))
            {
                // Create a copy of segments and update their part numbers to match new position
                var updatedSegments = segments.Select(segment => new SegmentCreateDto
                {
                    Id = segment.Id,
                    Lyric = segment.Lyric,
                    ChordId = segment.ChordId,
                    ChordName = segment.ChordName,
                    LineNumber = segment.LineNumber,
                    PartNumber = newPartNumber, // Use position-based numbering
                    PartName = tab.SectionEnumValue,
                    LyricOrder = segment.LyricOrder,
                    AddNextSegment = segment.AddNextSegment,
                    ChordAlignment = segment.ChordAlignment
                }).ToList();

                newAllPartsSegments[tab.Id] = updatedSegments;
            }
            else
            {
                // Create empty list for new tabs
                newAllPartsSegments[tab.Id] = new List<SegmentCreateDto>();
            }
        }

        AllPartsSegments = newAllPartsSegments;

        // Force re-render of the tabs content by triggering StateHasChanged
        StateHasChanged();
    }

    private async Task HandleSongBookChanged(SongBookDto? newSongBook)
    {
        selectedSongBook = newSongBook;
        songData.SongBookId = newSongBook?.Id;
        // Reset selected category when song book changes
        selectedCategory = null;
        songData.CategoryId = null;

        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleCategoryChanged(CategoryDto? newCategory)
    {
        selectedCategory = newCategory;
        songData.CategoryId = newCategory?.Id;
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleArtistChanged(ArtistDto? newArtist)
    {
        selectedArtist = newArtist;
        // Reset selected album when artist changes
        selectedAlbum = null;

        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleAlbumChanged(AlbumDto? newAlbum)
    {
        selectedAlbum = newAlbum;
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleRelocateLineRequest(RelocateLineActionDto relocateArgs)
    {
        // source part that contains the line to be moved
        var sourcePartId = relocateArgs.CurrentSectionId;

        if (sourcePartId == 0 || !AllPartsSegments.ContainsKey(sourcePartId))
        {
            ShowError("Source Section Error", "Could not determine the source section. Please try again.");
            return;
        }

        var sourceSegments = AllPartsSegments[sourcePartId]
            .Where(s => s.LineNumber == relocateArgs.CurrentLine)
            .ToList();

        if (!sourceSegments.Any())
        {
            ShowError("No Segments Found", "No segments found on the specified line to relocate.");
            return;
        }

        if (relocateArgs.CreateNewPart)
        {
            if (TabsComponentRef != null)
            {
                if (TabsComponentRef.Items.Count >= MAX_SECTIONS)
                {
                    ShowMaxSectionsError();
                    return;
                }
                try
                {
                    // Step 1: Remove segments from source BEFORE any other operations
                    AllPartsSegments[sourcePartId].RemoveAll(s => s.LineNumber == relocateArgs.CurrentLine);

                    // Step 2: Renumber remaining segments and trigger UI update
                    RenumberRemainingSegments(sourcePartId);

                    // Step 3: Check if source section is now empty BEFORE creating new section
                    var shouldRemoveSourceSection = AllPartsSegments[sourcePartId].Count == 0 &&
                                                    TabsComponentRef.Items.Count > 1; // Don't remove if it's the only section

                    // Step 4: Remove empty line tracking and force immediate UI refresh
                    await _tabsManager.RemoveEmptyLine(sourcePartId, relocateArgs.CurrentLine);
                    StateHasChanged();
                    await Task.Delay(50);

                    // Step 5: Create new tab
                    TabsComponentRef.HandleAddTab();
                    StateHasChanged();
                    await Task.Delay(50);

                    var newTabId = TabsComponentRef.Items.Max(i => i.Id);
                    var newTab = TabsComponentRef.Items.FirstOrDefault(item => item.Id == newTabId);

                    if (newTab != null && AllPartsSegments.ContainsKey(newTabId))
                    {
                        // Step 6: Prepare segments for new part
                        foreach (var segment in sourceSegments)
                        {
                            segment.PartNumber = newTab.SectionNumber;
                            segment.PartName = newTab.SectionEnumValue;
                            segment.LineNumber = 1; // Reset to line 1 in new part
                        }

                        // Step 7: Clear and add to new tab
                        AllPartsSegments[newTabId].Clear();
                        await _tabsManager.AddLineToSection(newTabId, 0, sourceSegments);

                        // Step 8: Remove empty source section if needed
                        if (shouldRemoveSourceSection)
                        {
                            await RemoveEmptySection(sourcePartId);
                        }

                        // Step 9: Switch to new tab and force final refresh
                        TabsComponentRef.SetSelectedTab(newTab);
                        activeTabItem = newTab;
                        _tabsManager.ActiveTab = newTab;

                        // Step 10: Force complete UI refresh
                        StateHasChanged();
                    }
                    else
                    {
                        ShowError("Tab Creation Failed", "Failed to create new section. Please try again.");
                        return;
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error creating new tab during line relocation");
                    ShowError("Error", "An error occurred while creating the new section.");
                    return;
                }
            }
        }
        else if (relocateArgs.TargetPart != null)
        {
            // Move to existing part
            var targetPartId = relocateArgs.TargetPart.Id;
            if (TabsComponentRef != null && !TabsComponentRef.Items.Any(item => item.Id == targetPartId))
            {
                ShowError("Target Section Not Found", "The target section no longer exists. Please try again.");
                return;
            }
            try
            {
                if (!AllPartsSegments.ContainsKey(targetPartId))
                {
                    AllPartsSegments[targetPartId] = new List<SegmentCreateDto>();
                }

                // Set the target tab as active FIRST
                if (TabsComponentRef != null)
                {
                    var targetTab = TabsComponentRef.Items.FirstOrDefault(item => item.Id == targetPartId);
                    if (targetTab != null)
                    {
                        TabsComponentRef.SetSelectedTab(targetTab);
                        activeTabItem = targetTab;
                        _tabsManager.ActiveTab = targetTab;
                    }
                }

                // Find the next available line number in target part
                var targetSegments = AllPartsSegments[targetPartId];
                var maxLineInTarget = targetSegments.Any()
                    ? targetSegments.Max(s => s.LineNumber)
                    : 0;

                // REMOVE source segments FIRST to avoid duplication
                AllPartsSegments[sourcePartId].RemoveAll(s => s.LineNumber == relocateArgs.CurrentLine);

                // Renumber remaining segments in source part IMMEDIATELY
                RenumberRemainingSegments(sourcePartId);

                // Check if source section should be removed
                var shouldRemoveSourceSection = AllPartsSegments[sourcePartId].Count == 0 &&
                                                sourcePartId != targetPartId &&
                                                TabsComponentRef.Items.Count > 1; // Don't remove if it's the only section

                // Remove empty line tracking and force UI update
                await _tabsManager.RemoveEmptyLine(sourcePartId, relocateArgs.CurrentLine);
                StateHasChanged();
                await Task.Delay(100);

                // Update segments for target part
                foreach (var segment in sourceSegments)
                {
                    segment.PartNumber = relocateArgs.TargetPart.SectionNumber;
                    segment.PartName = relocateArgs.TargetPart.SectionEnumValue;
                    segment.LineNumber = maxLineInTarget + 1;
                }

                // NOW add the line with content to target section
                await _tabsManager.AddLineToSection(targetPartId, maxLineInTarget, sourceSegments);

                // Remove empty source section if needed
                if (shouldRemoveSourceSection)
                {
                    await RemoveEmptySection(sourcePartId);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error moving segments to target part");
                ShowError("Error", "An error occurred while moving the line to the target section.");
                return;
            }
        }

        // Final state refresh to ensure all UI components are updated
        StateHasChanged();
    }

    private void RenumberRemainingSegments(int partId)
    {
        if (!AllPartsSegments.ContainsKey(partId))
            return;

        var allRemainingSegments = AllPartsSegments[partId]
            .OrderBy(s => s.LineNumber)
            .ThenBy(s => s.LyricOrder)
            .ToList();

        // Group by line number and renumber both lines and lyric order
        var groupedByLine = allRemainingSegments
            .GroupBy(s => s.LineNumber)
            .OrderBy(g => g.Key)
            .ToList();

        int newLineNumber = 1;
        foreach (var lineGroup in groupedByLine)
        {
            var segmentsInLine = lineGroup.OrderBy(s => s.LyricOrder).ToList();

            for (int i = 0; i < segmentsInLine.Count; i++)
            {
                segmentsInLine[i].LineNumber = newLineNumber;
                segmentsInLine[i].LyricOrder = i + 1; // Ensure proper lyric ordering within the line
            }

            newLineNumber++;
        }

        // Update the collection to maintain proper ordering
        AllPartsSegments[partId] = allRemainingSegments;
    }

    private async Task RemoveEmptySection(int sectionId)
    {
        try
        {
            if (TabsComponentRef != null)
            {
                // Find the section to remove
                var sectionToRemove = TabsComponentRef.Items.FirstOrDefault(item => item.Id == sectionId);
                if (sectionToRemove != null)
                {
                    _logger.LogInformation("Removing empty section: {SectionName} {SectionNumber}",
                        sectionToRemove.SectionName, sectionToRemove.SectionNumber);

                    // Remove from TabsComponent
                    TabsComponentRef.Items.RemoveAll(item => item.Id == sectionId);

                    // Remove from AllPartsSegments
                    AllPartsSegments.Remove(sectionId);

                    // Update TabsManager and initial items
                    initialPartsItems = TabsComponentRef.Items;
                    _tabsManager.TabItems = TabsComponentRef.Items;

                    // If the active tab was removed, switch to the first available tab
                    if (activeTabItem?.Id == sectionId && TabsComponentRef.Items.Any())
                    {
                        var newActiveTab = TabsComponentRef.Items.First();
                        TabsComponentRef.SetSelectedTab(newActiveTab);
                        activeTabItem = newActiveTab;
                        _tabsManager.ActiveTab = newActiveTab;
                    }

                    // Force UI refresh
                    StateHasChanged();
                    await Task.Delay(50); // Small delay to ensure UI processes the change
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error removing empty section {SectionId}", sectionId);
        }
    }

    private async Task HandleTabRemove(int tabId)
    {
        if (AllPartsSegments.ContainsKey(tabId))
        {
            AllPartsSegments.Remove(tabId);
            if (TabsComponentRef != null)
            {
                initialPartsItems = TabsComponentRef.Items; //syncing items data
                _tabsManager.TabItems = TabsComponentRef.Items; //syncing manager data
            }
            await InvokeAsync(StateHasChanged);
        }        
    }

    private void ShowMaxSectionsError()
    {
        _modalService.Show(new ModalOptionDto
        {
            Title = "Maximum Sections Reached",
            Message = $"Cannot create new section. Maximum of {MAX_SECTIONS} sections allowed.",
            ButtonText = "OK",
            OptionType = OptionType.Warning
        });
    }

    private void ShowError(string title, string message)
    {
        _modalService.Show(new ModalOptionDto
        {
            Title = title,
            Message = message,
            ButtonText = "OK",
            OptionType = OptionType.Error
        });
    }

    private async void ChangeBookSelection()
    {
        selectedSongBook = null;
        selectedCategory = null;
        songData.SongBookId = null;
        songData.CategoryId = null;
        StateHasChanged();

        if (songBookDropdownRef != null)
        {
            await songBookDropdownRef.FocusInput();
        }
    }
    
    private async void ChangeArtistSelection()
    {
        selectedArtist = null;
        selectedAlbum = null;
        StateHasChanged();

        if (artistDropdownRef != null)
        {
            await artistDropdownRef.FocusInput();
        }
    }

    private async Task ConfirmModal()
    {
        // handle specific contexts awaiting confirmation
        if (_modalService.CurrentModal.Context?.ActionType == "SongSaved")
        {
            _modalService.Close();
            _navManager.NavigateTo("/songs-list");
        }
        await CloseModal();
    }

    private async Task CloseModal()
    {
        _modalService.Close();
        await Task.CompletedTask;
    }

    public void Dispose()
    {
        _tabsManager.OnRelocateLine -= HandleRelocateLineRequest;
    }
}