@page "/compose"
@using Microsoft.AspNetCore.WebUtilities
@attribute [Authorize(Roles = $"{nameof(UserRoles.Editor)},{nameof(UserRoles.Contributor)}")]
@implements IDisposable
@inject ILogger<SongBoard> _logger

<div class="w-100 d-flex flex-column justify-content-center"
     style="max-width: 65rem;justify-self: center;">
	<h3 class="fw-bold text-center mb-3">Song Editor</h3>
    @if (isLoading)
    {
        <div class="d-flex justify-content-center my-5">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
    }
    else
    {
        @if (cacheData != null)
        {
            <div class="alert alert-info d-flex align-items-center justify-content-between mb-3" role="alert">
                <div>
                    <i class="bi bi-info-circle me-2"></i>
                    <strong>Session Recovery:</strong> Unsaved changes detected. Would you like to restore your previous work?
                </div>
                <div>
                    <button type="button" class="btn btn-sm btn-primary me-2" @onclick="RestoreFromCache">
                        <i class="bi bi-arrow-clockwise me-1"></i>Restore
                    </button>
                    <button type="button" class="btn btn-sm btn-outline-secondary" @onclick="DiscardCache">
                        <i class="bi bi-x-circle me-1"></i>Discard
                    </button>
                </div>
            </div>
        }

        <div class="row row-cols-lg-12 g-2 align-items-center">
            <!-- Input 1 -->
            <div class="col-4 col-md-2">
                <input type="number"
                       @bind="FormattedSongNumber"
                       class="form-control"
                       placeholder="Song #"
                       min="1" />
            </div>

            <!-- Input 2 -->
            <div class="col-8 col-md-4">
                <input type="text"
                       @bind="SongTitle"
                       class="form-control"
                       placeholder="Song Title" />
            </div>

            <!--Input 3 book/Artist-->
            <div class="col-9 col-md-4">
                <BookArtistAdd @ref="bookArtistAddRef"
                               OnBookCategoryChanged="HandleBookCategoryChanged"
                               OnArtistAlbumChanged="HandleArtistAlbumChanged"
                               SongNumber="@SongNumber" />
            </div>

            <!-- Save Button -->
            <div class="col-3 col-md-2 d-grid">
                <button type="button"
                        class="btn btn-outline-primary"
                        @onclick="HandleSongSave">
                    <span class="me-2 d-none d-md-inline">Save Song</span>
                    <i class="bi bi-clipboard-check"></i>
                </button>
            </div>
        </div>

        @if (initialPartsItems.Any())
        {
            <TabsComponent @ref="TabsComponentRef"
                           InitialItems="initialPartsItems"
                           ItemsCountLimit="MAX_SECTIONS"
                           OnTabAdd="HandleTabAdd"
                           RenderTab="RenderVerseTab"
                           OnTabSort="HandleTabSort"
                           OnTabRemoved="HandleTabRemove"
                           ActiveTabInfoChanged ="HandleActiveTabInfoChanged"/>
        }
        else
        {
            <div class="alert alert-warning mt-2">
                No sections found. Click to <span class="btn-link" style="cursor:pointer" @onclick="InitializeNewContent">add a new section</span>
            </div>
        }
    }
    
</div>
<SongDataPreview @ref="songPreviewRef"
                 IsVisible="showPreview"
                 SongData="songData"
                 OnCancel="HandlePreviewCancel"
                 OnSave="HandlePreviewSave" />

<DialogModal IsVisible="@_modalService.IsModalVisible"
             Modal="@_modalService.CurrentModal"
             OnCloseModal="CloseModal"
             OnConfirmModal="ConfirmModal" />

@code {
    [Parameter]
    public string? SongId { get; set; }
    const int MAX_SECTIONS = 25;
    private string SongTitle = "My New Song";
    private int SongNumber = 1;   
    private Dictionary<int, List<SegmentCreateDto>> AllPartsSegments =
    new() { [1] = new List<SegmentCreateDto>() };
    private List<TabItem> initialPartsItems = new();
    private TabItem? activeTabItem;

    private SongBookDto? selectedSongBook = null;
    private CategoryDto? selectedCategory = null;

    private ArtistDto? selectedArtist = null;
    private AlbumDto? selectedAlbum = null;

    private SimpleSongCreateDto songData = new(); 
    private SimpleSongCreateDto? cacheData;
    private BookArtistAdd? bookArtistAddRef;
    private TabsComponent? TabsComponentRef;
    private const int MAX_TITLE_LEN = 15;
    private bool isLoading = true;
    private BookCategoryPairViewModel? currentBookCategory = null;
    private ArtistAlbumPairViewModel? currentArtistAlbum = null;
    private SongDataPreview? songPreviewRef;
    private bool showPreview = false;

    private IDisposable? _locationChangingRegistration;

    private RenderFragment RenderVerseTab(int id) => @<SongSectionBoard SectionId="@id"
                  Segments="@AllPartsSegments.GetValueOrDefault(id, new List<SegmentCreateDto>())"
                  ActiveTab="activeTabItem" 
                  OnSegmentsUpdate="segments => HandleVerseUpdate(id, segments)" />
    ;
    private string FormattedSongNumber
    {
        get => SongNumber.ToString("D3");
        set
        {
            if (int.TryParse(value, out var num))
            {
                SongNumber = num;
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var uri = _navManager.ToAbsoluteUri(_navManager.Uri);
            var query = QueryHelpers.ParseQuery(uri.Query);
            if (query.TryGetValue("songId", out var songIdValues))
            {
                SongId = songIdValues.FirstOrDefault();
            }
            var cachedData = await _storageService
                    .GetItemAsync<SimpleSongCreateDto>("songDraft");
            if (cachedData != null)
            {
                cacheData = cachedData;
            }
            if (string.IsNullOrEmpty(SongId))
            {
                InitializeNewContent();
            }
            else
            {
                var response = await _songsApi.GetSongWithChordsById(SongId);
                if (response.IsSuccessStatusCode)
                {
                    var song = response.Content!;
                    SongTitle = song.Title;
                    SongNumber = song.SongNumber ?? 0;
                    initialPartsItems = new List<TabItem>();
                    AllPartsSegments = new Dictionary<int, List<SegmentCreateDto>>();
                    if (!string.IsNullOrEmpty(song.AlbumId)) GetAlbum(song.AlbumId);
                    else if (!string.IsNullOrEmpty(song.CategoryId)) GetBookCategory(song.CategoryId);

                    // Process parts
                    foreach (var part in song.SongParts!.OrderBy(v => v.PartNumber))
                    {
                        var verseSegments = new List<SegmentCreateDto>();
                        foreach (var line in part.LyricLines!.OrderBy(ll => ll.LyricLineOrder))
                        {
                            foreach (var segment in line.LyricSegments!.OrderBy(ls => ls.LyricOrder))
                            {
                                verseSegments.Add(new SegmentCreateDto
                                    {
                                        Id = segment.Id.ToString(),
                                        Lyric = segment.Lyric,
                                        ChordId = segment.ChordId?.ToString(),
                                        ChordName = segment.Chord?.ChordName,
                                        ChordAlignment = segment.ChordAlignment,
                                        LineNumber = line.LyricLineOrder,
                                        PartNumber = part.PartNumber,
                                        PartName = part.PartName ?? SongSection.Verse,
                                        LyricOrder = segment.LyricOrder
                                    });
                            }
                        }

                        AllPartsSegments[part.PartNumber] = verseSegments;

                        initialPartsItems.Add(new TabItem
                            {
                                Id = part.PartNumber,
                                SectionName = part.PartName.ToString() ?? nameof(SongSection.Verse),
                                SectionNumber = part.PartNumber,
                                Content = builder =>
                                {
                                    builder.OpenComponent<SongSectionBoard>(0);
                                    builder.AddAttribute(1, "SectionId", part.PartNumber);
                                    builder.AddAttribute(2, "OnSegmentsUpdate",
                                        EventCallback.Factory.Create<List<SegmentCreateDto>>(
                                            this, segments => HandleVerseUpdate(part.PartNumber, segments)));
                                    builder.AddAttribute(3, "Segments", AllPartsSegments[part.PartNumber]);
                                    builder.AddAttribute(4, "ActiveTab", activeTabItem);
                                    builder.CloseComponent();
                                }
                            });
                    }
                }
                else
                {
                    var errorMessage = _apiResponseHandler.GetApiErrorMessage(response);
                    _modalService.Show(new ModalOptionDto
                    {
                        Title = "Error",
                        Message = errorMessage,
                        ButtonText = "Close",
                        OptionType = OptionType.Error,
                        Context = new ModalContext
                        {
                            ActionType = "SongLoadError",
                            Data = response.Content?.ToString() ?? "No content"
                        }
                    });
                }
            }
            _tabsManager.OnRelocateLine += HandleRelocateLineRequest;
            _locationChangingRegistration = _navManager.RegisterLocationChangingHandler(HandleLocationChanging);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error initializing song board");
            _modalService.Show(new ModalOptionDto
            {
                Title = "Initialization Error",
                Message = "An error occurred while initializing the song board. Please try again later.",
                ButtonText = "Close",
                OptionType = OptionType.Error,
                Context = new ModalContext
                {
                    ActionType = "InitializationError",
                    Data = ex.Message
                }
            });            
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }

    }

    private async void GetAlbum(string albumId)
    {
        var albumResponse = await _albumsApi.GetAlbumById(albumId);
        if (albumResponse.IsSuccessStatusCode)
        {
            var album = albumResponse.Content!;
            selectedAlbum = album;
            var artistResponse = await _artistsApi.GetArtistById(album.ArtistId ?? "");
            if (artistResponse.IsSuccessStatusCode)
            {
                selectedArtist = artistResponse.Content!;
                if (bookArtistAddRef != null)
                    await bookArtistAddRef.SetArtistAlbumPair(new ArtistAlbumPairViewModel
                    {
                        ArtistId = selectedArtist.Id,
                        ArtistName = selectedArtist.Name,
                        AlbumId = selectedAlbum.Id,
                        AlbumTitle = selectedAlbum.Title,
                        TrackNumber = 1
                    });
            }
        }
        if (selectedAlbum !=null || selectedArtist != null)
        {
            if( bookArtistAddRef != null)
                await bookArtistAddRef. SetActiveSelectionTab("artist");           
        }
        StateHasChanged();  
    }

    private async void GetBookCategory(string categoryId)
    {
        var categoryResponse = await _categoriesApi.GetCategoryById(categoryId);
        if (categoryResponse.IsSuccessStatusCode)
        {
            selectedCategory = categoryResponse.Content!;
            if (!string.IsNullOrEmpty(selectedCategory.SongBookId))
            {
                var bookResponse = await _songsBooksApi.GetSongBookById(selectedCategory.SongBookId);
                if (bookResponse.IsSuccessStatusCode)
                {
                    selectedSongBook = bookResponse.Content!;
                    if (bookArtistAddRef != null)
                        await bookArtistAddRef.SetSongBookCategoryPair(new BookCategoryPairViewModel
                        {
                            SongBookId = selectedSongBook.Id,
                            BookTitle = selectedSongBook.Title,
                            CategoryId = selectedCategory.Id,
                            CategoryName = selectedCategory.Name
                        });
                }
            }
        }
        if (selectedCategory != null || selectedSongBook != null)
        {
            if (bookArtistAddRef != null)
                await bookArtistAddRef.SetActiveSelectionTab("songbook");            
        }
        StateHasChanged();
    }

    private void InitializeNewContent()
    {
        // Initialize new song
        initialPartsItems = new List<TabItem>
                {
                    new TabItem
                    {
                        Id = 1,
                        SectionName = nameof(SongSection.Verse),
                        SectionNumber = 1,
                        Content = builder =>
                        {
                            builder.OpenComponent<SongSectionBoard>(0);
                            builder.AddAttribute(1, "SectionId", 1);
                            builder.AddAttribute(2, "OnSegmentsUpdate",
                                EventCallback.Factory.Create<List<SegmentCreateDto>>(
                                    this, segments => HandleVerseUpdate(1, segments)));
                            builder.AddAttribute(3, "Segments", AllPartsSegments[1]);
                            builder.AddAttribute(4, "ActiveTab", activeTabItem);
                            builder.CloseComponent();
                        }
                    }
                };
        AllPartsSegments[1] = new List<SegmentCreateDto>();
    }

    private async Task HandleSongSave()
    {
        var allSegments = AllPartsSegments.Values.SelectMany(v => v).ToList();

        songData.Title = SongTitle;
        songData.SongNumber = SongNumber;
        songData.SongLyrics = allSegments;

        // Map single BookCategory pair if exists
        songData.BookCategory = currentBookCategory != null
            ? new BookCategoryPairViewModel
                {
                    BookTitle = currentBookCategory.BookTitle,
                CategoryName = currentBookCategory.CategoryName,
                    SongBookId = currentBookCategory.SongBookId,
                    CategoryId = currentBookCategory.CategoryId
                }
            : null;

        songData.ArtistAlbum = currentArtistAlbum != null
            ? new ArtistAlbumPairViewModel
            {
                ArtistName = currentArtistAlbum.ArtistName,
                AlbumTitle = currentArtistAlbum.AlbumTitle,
                ArtistId = currentArtistAlbum.ArtistId,
                AlbumId = currentArtistAlbum.AlbumId,
                TrackNumber = currentArtistAlbum.TrackNumber
            }
            :null;

        if (allSegments.Count == 0)
        {
            _modalService.Show(new ModalOptionDto
            {
                Title = "No Segments",
                Message = "Please add at least one segment to save the song.",
                ButtonText = "OK",
                OptionType = OptionType.Warning,
                Context = new ModalContext
                {
                    ActionType = "NoSegments",
                    Data = "Attempted to save song with no segments"
                }
            });

            _logger.LogWarning("No segments found to save.");
            return;
        }

        showPreview = true;
        StateHasChanged();
    }
    private async Task HandlePreviewCancel()
    {
        showPreview = false;
        StateHasChanged();
    }

    private async Task HandlePreviewSave()
    {
        showPreview = false;
        await HandleSongPreview(songData);
    }
    private async Task HandleSongPreview(SimpleSongCreateDto songData)
    {
        Refit.IApiResponse<SongDto> songResult;
        if (string.IsNullOrEmpty(SongId) || SongId == "new")
        {
            SongId = null;
            songResult = await _songsApi.CreateSong(songData);
        }
        else
        {
            songResult = await _songsApi.UpdateSong(SongId, songData);
        }

        if (songResult.IsSuccessStatusCode)
        {
            songData = new SimpleSongCreateDto();
            _modalService.Show(new ModalOptionDto
            {
                Title = "Song Saved",
                Message = $"Song '{SongTitle}' saved successfully!",
                ButtonText = "OK",
                OptionType = OptionType.Success,
                Context = new ModalContext
                {
                    ActionType = "SongSaved",
                    Data = songResult.Content?.ToString() ?? "No content"
                }
            });

            _logger.LogInformation("Song {songData} saved successfully!", songData);
        }
        else
        {
            var errorMessage = _apiResponseHandler.GetApiErrorMessage(songResult);
            _modalService.Show(new ModalOptionDto
            {
                Title = "Save Error",
                Message = errorMessage,
                ButtonText = "Close",
                OptionType = OptionType.Error,
                Context = new ModalContext
                {
                    ActionType = "SongSaveError",
                    Data = songResult.Content?.ToString() ?? "No content"
                }
            });

            _logger.LogError("Failed to save song: {Error}", errorMessage);
        }
    }

    private void HandleActiveTabInfoChanged(TabItem tabItem)
    {
        activeTabItem = tabItem;

        if (AllPartsSegments.TryGetValue(tabItem.Id, out var segments))
        {
            foreach (var segment in segments)
            {
                segment.PartNumber = tabItem.SectionNumber;
                segment.PartName = tabItem.SectionEnumValue;
            }
        }
        StateHasChanged();
    }

    private void HandleVerseUpdate(int sectionId, List<SegmentCreateDto> segments)
    {
        AllPartsSegments[sectionId] = segments; 
    }

    private void HandleTabAdd(int newTabId)
    {
        if (!AllPartsSegments.ContainsKey(newTabId))
        {
            AllPartsSegments[newTabId] = new List<SegmentCreateDto>();
            if(TabsComponentRef != null)
            {
                initialPartsItems = TabsComponentRef.Items; //syncing items data
                _tabsManager.TabItems = TabsComponentRef.Items; //syncing manager data
            }
        }
    }

    private void HandleTabSort(List<TabItem> sortedItems)
    {
        // Create new segments dictionary preserving the content but updating positions
        var newAllPartsSegments = new Dictionary<int, List<SegmentCreateDto>>();

        // Copy segments to their new positions and update part numbers
        for (int i = 0; i < sortedItems.Count; i++)
        {
            var tab = sortedItems[i];
            var newPartNumber = i + 1; // Position-based part number (1, 2, 3, etc.)

            if (AllPartsSegments.TryGetValue(tab.Id, out var segments))
            {
                // Create a copy of segments and update their part numbers to match new position
                var updatedSegments = segments.Select(segment => new SegmentCreateDto
                {
                    Id = segment.Id,
                    Lyric = segment.Lyric,
                    ChordId = segment.ChordId,
                    ChordName = segment.ChordName,
                    LineNumber = segment.LineNumber,
                    PartNumber = newPartNumber, // Use position-based numbering
                    PartName = tab.SectionEnumValue,
                    LyricOrder = segment.LyricOrder,
                    AddNextSegment = segment.AddNextSegment,
                    ChordAlignment = segment.ChordAlignment
                }).ToList();

                newAllPartsSegments[tab.Id] = updatedSegments;
            }
            else
            {
                // Create empty list for new tabs
                newAllPartsSegments[tab.Id] = new List<SegmentCreateDto>();
            }
        }

        AllPartsSegments = newAllPartsSegments;

        // Force re-render of the tabs content by triggering StateHasChanged
        StateHasChanged();
    }

    private async Task HandleRelocateLineRequest(RelocateLineActionDto relocateArgs)
    {
        // source part that contains the line to be moved
        var sourcePartId = relocateArgs.CurrentSectionId;

        if (sourcePartId == 0 || !AllPartsSegments.ContainsKey(sourcePartId))
        {
            ShowError("Source Section Error", "Could not determine the source section. Please try again.");
            return;
        }

        var sourceSegments = AllPartsSegments[sourcePartId]
            .Where(s => s.LineNumber == relocateArgs.CurrentLine)
            .ToList();

        if (!sourceSegments.Any())
        {
            ShowError("No Segments Found", "No segments found on the specified line to relocate.");
            return;
        }

        if (relocateArgs.CreateNewPart)
        {
            if (TabsComponentRef != null)
            {
                if (TabsComponentRef.Items.Count >= MAX_SECTIONS)
                {
                    ShowMaxSectionsError();
                    return;
                }
                try
                {
                    // Step 1: Remove segments from source BEFORE any other operations
                    AllPartsSegments[sourcePartId].RemoveAll(s => s.LineNumber == relocateArgs.CurrentLine);

                    // Step 2: Renumber remaining segments and trigger UI update
                    RenumberRemainingSegments(sourcePartId);

                    // Step 3: Check if source section is now empty BEFORE creating new section
                    var shouldRemoveSourceSection = AllPartsSegments[sourcePartId].Count == 0 &&
                                                    TabsComponentRef.Items.Count > 1; // Don't remove if it's the only section

                    // Step 4: Remove empty line tracking and force immediate UI refresh
                    await _tabsManager.RemoveEmptyLine(sourcePartId, relocateArgs.CurrentLine);
                    StateHasChanged();
                    await Task.Delay(50);

                    // Step 5: Create new tab
                    TabsComponentRef.HandleAddTab();
                    StateHasChanged();
                    await Task.Delay(50);

                    var newTabId = TabsComponentRef.Items.Max(i => i.Id);
                    var newTab = TabsComponentRef.Items.FirstOrDefault(item => item.Id == newTabId);

                    if (newTab != null && AllPartsSegments.ContainsKey(newTabId))
                    {
                        // Step 6: Prepare segments for new part
                        foreach (var segment in sourceSegments)
                        {
                            segment.PartNumber = newTab.SectionNumber;
                            segment.PartName = newTab.SectionEnumValue;
                            segment.LineNumber = 1; // Reset to line 1 in new part
                        }

                        // Step 7: Clear and add to new tab
                        AllPartsSegments[newTabId].Clear();
                        await _tabsManager.AddLineToSection(newTabId, 0, sourceSegments);

                        // Step 8: Remove empty source section if needed
                        if (shouldRemoveSourceSection)
                        {
                            await RemoveEmptySection(sourcePartId);
                        }

                        // Step 9: Switch to new tab and force final refresh
                        TabsComponentRef.SetSelectedTab(newTab);
                        activeTabItem = newTab;
                        _tabsManager.ActiveTab = newTab;

                        // Step 10: Force complete UI refresh
                        StateHasChanged();
                    }
                    else
                    {
                        ShowError("Tab Creation Failed", "Failed to create new section. Please try again.");
                        return;
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error creating new tab during line relocation");
                    ShowError("Error", "An error occurred while creating the new section.");
                    return;
                }
            }
        }
        else if (relocateArgs.TargetPart != null)
        {
            // Move to existing part
            var targetPartId = relocateArgs.TargetPart.Id;
            if (TabsComponentRef != null && !TabsComponentRef.Items.Any(item => item.Id == targetPartId))
            {
                ShowError("Target Section Not Found", "The target section no longer exists. Please try again.");
                return;
            }
            try
            {
                if (!AllPartsSegments.ContainsKey(targetPartId))
                {
                    AllPartsSegments[targetPartId] = new List<SegmentCreateDto>();
                }

                // Set the target tab as active FIRST
                if (TabsComponentRef != null)
                {
                    var targetTab = TabsComponentRef.Items.FirstOrDefault(item => item.Id == targetPartId);
                    if (targetTab != null)
                    {
                        TabsComponentRef.SetSelectedTab(targetTab);
                        activeTabItem = targetTab;
                        _tabsManager.ActiveTab = targetTab;
                    }
                }

                // Find the next available line number in target part
                var targetSegments = AllPartsSegments[targetPartId];
                var maxLineInTarget = targetSegments.Any()
                    ? targetSegments.Max(s => s.LineNumber)
                    : 0;

                // REMOVE source segments FIRST to avoid duplication
                AllPartsSegments[sourcePartId].RemoveAll(s => s.LineNumber == relocateArgs.CurrentLine);

                // Renumber remaining segments in source part IMMEDIATELY
                RenumberRemainingSegments(sourcePartId);

                // Check if source section should be removed
                var shouldRemoveSourceSection = AllPartsSegments[sourcePartId].Count == 0 &&
                                                sourcePartId != targetPartId &&
                                                TabsComponentRef.Items.Count > 1; // Don't remove if it's the only section

                // Remove empty line tracking and force UI update
                await _tabsManager.RemoveEmptyLine(sourcePartId, relocateArgs.CurrentLine);
                StateHasChanged();
                await Task.Delay(100);

                // Update segments for target part
                foreach (var segment in sourceSegments)
                {
                    segment.PartNumber = relocateArgs.TargetPart.SectionNumber;
                    segment.PartName = relocateArgs.TargetPart.SectionEnumValue;
                    segment.LineNumber = maxLineInTarget + 1;
                }

                // NOW add the line with content to target section
                await _tabsManager.AddLineToSection(targetPartId, maxLineInTarget, sourceSegments);

                // Remove empty source section if needed
                if (shouldRemoveSourceSection)
                {
                    await RemoveEmptySection(sourcePartId);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error moving segments to target part");
                ShowError("Error", "An error occurred while moving the line to the target section.");
                return;
            }
        }

        // Final state refresh to ensure all UI components are updated
        StateHasChanged();
    }

    private void RenumberRemainingSegments(int partId)
    {
        if (!AllPartsSegments.ContainsKey(partId))
            return;

        var allRemainingSegments = AllPartsSegments[partId]
            .OrderBy(s => s.LineNumber)
            .ThenBy(s => s.LyricOrder)
            .ToList();

        // Group by line number and renumber both lines and lyric order
        var groupedByLine = allRemainingSegments
            .GroupBy(s => s.LineNumber)
            .OrderBy(g => g.Key)
            .ToList();

        int newLineNumber = 1;
        foreach (var lineGroup in groupedByLine)
        {
            var segmentsInLine = lineGroup.OrderBy(s => s.LyricOrder).ToList();

            for (int i = 0; i < segmentsInLine.Count; i++)
            {
                segmentsInLine[i].LineNumber = newLineNumber;
                segmentsInLine[i].LyricOrder = i + 1; // Ensure proper lyric ordering within the line
            }

            newLineNumber++;
        }

        // Update the collection to maintain proper ordering
        AllPartsSegments[partId] = allRemainingSegments;
    }

    private async Task RemoveEmptySection(int sectionId)
    {
        try
        {
            if (TabsComponentRef != null)
            {
                // Find the section to remove
                var sectionToRemove = TabsComponentRef.Items.FirstOrDefault(item => item.Id == sectionId);
                if (sectionToRemove != null)
                {
                    _logger.LogInformation("Removing empty section: {SectionName} {SectionNumber}",
                        sectionToRemove.SectionName, sectionToRemove.SectionNumber);

                    // Remove from TabsComponent
                    TabsComponentRef.Items.RemoveAll(item => item.Id == sectionId);

                    // Remove from AllPartsSegments
                    AllPartsSegments.Remove(sectionId);

                    // Update TabsManager and initial items
                    initialPartsItems = TabsComponentRef.Items;
                    _tabsManager.TabItems = TabsComponentRef.Items;

                    // If the active tab was removed, switch to the first available tab
                    if (activeTabItem?.Id == sectionId && TabsComponentRef.Items.Any())
                    {
                        var newActiveTab = TabsComponentRef.Items.First();
                        TabsComponentRef.SetSelectedTab(newActiveTab);
                        activeTabItem = newActiveTab;
                        _tabsManager.ActiveTab = newActiveTab;
                    }

                    // Force UI refresh
                    StateHasChanged();
                    await Task.Delay(50); // Small delay to ensure UI processes the change
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error removing empty section {SectionId}", sectionId);
        }
    }

    private async Task HandleTabRemove(int tabId)
    {
        if (AllPartsSegments.ContainsKey(tabId))
        {
            AllPartsSegments.Remove(tabId);
            if (TabsComponentRef != null)
            {
                initialPartsItems = TabsComponentRef.Items; //syncing items data
                _tabsManager.TabItems = TabsComponentRef.Items; //syncing manager data
            }
            await InvokeAsync(StateHasChanged);
        }        
    }

    private void ShowMaxSectionsError()
    {
        _modalService.Show(new ModalOptionDto
        {
            Title = "Maximum Sections Reached",
            Message = $"Cannot create new section. Maximum of {MAX_SECTIONS} sections allowed.",
            ButtonText = "OK",
            OptionType = OptionType.Warning
        });
    }

    private void ShowError(string title, string message)
    {
        _modalService.Show(new ModalOptionDto
        {
            Title = title,
            Message = message,
            ButtonText = "OK",
            OptionType = OptionType.Error
        });
    }

    private string GetTruncatedTitle(string title)
    {
        return title.Length > MAX_TITLE_LEN
            ? title.Substring(0, MAX_TITLE_LEN) + "…"
            : title;
    }

    private async Task HandleBookCategoryChanged(BookCategoryPairViewModel? bookCategory)
    {
        currentBookCategory = bookCategory;

        // Clear artist/album when book/category is set
        if (bookCategory != null)
        {
            currentArtistAlbum = null;
            selectedArtist = null;
            selectedAlbum = null;
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleArtistAlbumChanged(ArtistAlbumPairViewModel? artistAlbum)
    {
        currentArtistAlbum = artistAlbum;

        // Clear book/category when artist/album is set
        if (artistAlbum != null)
        {
            currentBookCategory = null;
            selectedSongBook = null;
            selectedCategory = null;
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task ConfirmModal()
    {
        // handle specific contexts awaiting confirmation
        if (_modalService.CurrentModal.Context?.ActionType == "SongSaved")
        {
            _modalService.Close();
            _navManager.NavigateTo("/songs-list");
        }
        else if (_modalService.CurrentModal.Context?.ActionType == "RestoreFromCache")
        {
            // Save current work first
            await HandleSongSave();
            _modalService.Close();
            // Then restore from cache
            await PerformCacheRestore();
        }
        else
        {
            await CloseModal();
        }
    }

    private async Task CloseModal()
    {
        if (_modalService.CurrentModal?.Context?.ActionType == "RestoreFromCache" &&
                _modalService.CurrentModal?.Context?.Data.ToString() == "HasCurrentWork")
        {
            await PerformCacheRestore();
        }
        _modalService.Close();
        await Task.CompletedTask;
    }

    private async Task RestoreFromCache()
    {
        // Check if there's unsaved current work
        var hasCurrentWork = currentBookCategory != null||
                             currentArtistAlbum != null ||
                             AllPartsSegments.Values.Any(segments => segments.Any());

        if (hasCurrentWork)
        {
            _modalService.Show(new ModalOptionDto
            {
                Title = "Unsaved Changes",
                Message = "You have unsaved work in the current editor. Do you want to save it before restoring from cache?",
                ButtonText = "Save & Restore",
                OptionType = OptionType.Warning,
                Context = new ModalContext
                {
                    ActionType = "RestoreFromCache",
                    Data = "HasCurrentWork"
                }
            });
            return;
        }

        await PerformCacheRestore();
    }

    private async Task PerformCacheRestore()
    {
        if (cacheData == null) return;

        try
        {
            ClearCurrentState();

            SongTitle = cacheData.Title;
            //SongNumber = cacheData.SongNumber ?? 1;

            // Restore book category with proper titles
            if (cacheData.BookCategory != null)
            {
                var bookResponse = await _songsBooksApi.GetSongBookById(cacheData.BookCategory.SongBookId);
                var bookTitle = bookResponse.IsSuccessStatusCode ? bookResponse.Content?.Title : "Unknown Book";
                string? categoryName = null;
                if (!string.IsNullOrEmpty(cacheData.BookCategory.CategoryId))
                {
                    var catResponse = await _categoriesApi.GetCategoryById(cacheData.BookCategory.CategoryId);
                    categoryName = catResponse.IsSuccessStatusCode ? catResponse.Content?.Name : null;
                }
                currentBookCategory = new BookCategoryPairViewModel
                    {
                        SongBookId = cacheData.BookCategory.SongBookId,
                        BookTitle = bookTitle ?? "Unknown",
                        CategoryId = cacheData.BookCategory.CategoryId,
                        CategoryName = categoryName,
                    };
                // Set active tab to songbook if we have book categories
                //activeSelectionTab = "songbook";
                if (bookArtistAddRef != null)
                {
                    await bookArtistAddRef.SetActiveSelectionTab("songbook");
                    await bookArtistAddRef.SetSongBookCategoryPair(currentBookCategory);
                }
            }                
            else if (cacheData.ArtistAlbum != null)// Restore artist album with proper names
            {
                var artistResponse = await _artistsApi.GetArtistById(cacheData.ArtistAlbum.ArtistId);
                var artistName = artistResponse.IsSuccessStatusCode ? artistResponse.Content?.Name : "Unknown Artist";
                string? albumTitle = null;
                if (!string.IsNullOrEmpty(cacheData.ArtistAlbum.AlbumId))
                {
                    var albumResponse = await _albumsApi.GetAlbumById(cacheData.ArtistAlbum.AlbumId);
                    albumTitle = albumResponse.IsSuccessStatusCode ? albumResponse.Content?.Title : null;
                }
                currentArtistAlbum = new ArtistAlbumPairViewModel
                {
                    ArtistId = cacheData.ArtistAlbum.ArtistId,
                    ArtistName = artistName,
                    AlbumId = cacheData.ArtistAlbum.AlbumId,
                    AlbumTitle = albumTitle,
                    TrackNumber = cacheData.ArtistAlbum.TrackNumber
                };

                if( bookArtistAddRef != null)
                {
                    await bookArtistAddRef.SetActiveSelectionTab("artist");
                    await bookArtistAddRef.SetArtistAlbumPair(currentArtistAlbum);
                }
            }

            // Restore segments and rebuild the entire UI structure
            if (cacheData.SongLyrics != null && cacheData.SongLyrics.Any())
            {
                // Group segments by part number
                var groupedSegments = cacheData.SongLyrics
                    .GroupBy(s => s.PartNumber)
                    .ToDictionary(g => g.Key, g => g.ToList());

                // Rebuild AllPartsSegments
                foreach (var partNum in groupedSegments.Keys.OrderBy(k => k))
                {
                    AllPartsSegments[partNum] = groupedSegments[partNum];
                }

                // Rebuild initialPartsItems from scratch
                var newTabItems = new List<TabItem>();

                foreach (var partNum in AllPartsSegments.Keys.OrderBy(k => k))
                {
                    var firstSegment = AllPartsSegments[partNum].FirstOrDefault();
                    var sectionName = firstSegment?.PartName.ToString() ?? nameof(SongSection.Verse);

                    // Create a new tab item with proper closure
                    var currentPartNum = partNum; // Capture for closure

                    newTabItems.Add(new TabItem
                    {
                        Id = currentPartNum,
                        SectionName = sectionName,
                        SectionNumber = currentPartNum,
                        DisplayOrder = newTabItems.Count + 1,
                        Content = builder =>
                        {
                            builder.OpenComponent<SongSectionBoard>(0);
                            builder.AddAttribute(1, "SectionId", currentPartNum);
                            builder.AddAttribute(2, "OnSegmentsUpdate",
                                EventCallback.Factory.Create<List<SegmentCreateDto>>(
                                    this, segments => HandleVerseUpdate(currentPartNum, segments)));
                            builder.AddAttribute(3, "Segments", AllPartsSegments[currentPartNum]);
                            builder.AddAttribute(4, "ActiveTab", activeTabItem);
                            builder.CloseComponent();
                        }
                    });
                }

                initialPartsItems = newTabItems;
            }
            else
            {
                InitializeNewContent();
            }

            // Clear cache
            cacheData = null;
            await _storageService.RemoveItemAsync("songDraft");
            _tabsManager.TabsComponentKey = Guid.NewGuid().ToString();
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during cache restoration");
            _modalService.Show(new ModalOptionDto
            {
                Title = "Restoration Error",
                Message = "An error occurred while restoring your work. Please try again.",
                ButtonText = "Close",
                OptionType = OptionType.Error
            });
        }
    }

    private void ClearCurrentState()
    {
        // Clear current state completely
        SongTitle = "";
        SongNumber = 1;

        currentArtistAlbum = null;
        currentArtistAlbum = null;
        AllPartsSegments.Clear();
        initialPartsItems.Clear();
    }

    private void DiscardCache()
    {
        cacheData = null;
        _storageService.RemoveItemAsync("songDraft");
        StateHasChanged();
    }

    private async ValueTask HandleLocationChanging(LocationChangingContext context)
    {
        // Check if there's unsaved work
        var hasUnsavedWork = currentBookCategory != null ||
                             currentArtistAlbum != null ||
                             AllPartsSegments.Values.Any(segments => segments.Any());

        if (hasUnsavedWork)
        {
            try
            {
                // Save current work to cache
                var allSegments = AllPartsSegments.Values.SelectMany(v => v).ToList();

                var draftData = new SimpleSongCreateDto
                {
                    Title = SongTitle,
                    SongNumber = SongNumber,
                    SongLyrics = allSegments,
                    BookCategory = currentBookCategory != null
                        ? new BookCategoryPairViewModel
                        {
                            SongBookId = currentBookCategory.SongBookId,
                            CategoryId = currentBookCategory.CategoryId
                        }
                        : null,
                    ArtistAlbum = currentArtistAlbum != null
                        ? new ArtistAlbumPairViewModel
                        {
                            ArtistId = currentArtistAlbum.ArtistId,
                            AlbumId = currentArtistAlbum.AlbumId
                        }
                        : null
                };

                await _storageService.SetItemAsync("songDraft", draftData);
                _logger.LogInformation("Saved draft before navigation");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error saving draft during navigation");
            }
        }
    }
        

    public void Dispose()
    {
        _tabsManager.OnRelocateLine -= HandleRelocateLineRequest;
        _locationChangingRegistration?.Dispose();
    }

}